// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: db_player.proto

#ifndef PROTOBUF_db_5fplayer_2eproto__INCLUDED
#define PROTOBUF_db_5fplayer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "item.pb.h"
#include "db_data.pb.h"
#include "db_item.pb.h"
#include "db_skill.pb.h"
#include "db_quest.pb.h"
#include "db_shop.pb.h"
#include "db_talent.pb.h"
#include "db_friend.pb.h"
#include "db_dungeon.pb.h"
#include "lively.pb.h"
#include "title.pb.h"
#include "db_activity.pb.h"
#include "db_welfare.pb.h"
#include "db_achieve.pb.h"
#include "parkour.pb.h"
#include "match.pb.h"
#include "player.pb.h"
#include "godweapon.pb.h"
#include "ride.pb.h"
#include "pet.pb.h"
#include "awaken.pb.h"
#include "mercenary.pb.h"
#include "boat.pb.h"
#include "marketing.pb.h"
#include "shop.pb.h"
// @@protoc_insertion_point(includes)

namespace proto {
namespace message {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_db_5fplayer_2eproto();
void protobuf_AssignDesc_db_5fplayer_2eproto();
void protobuf_ShutdownFile_db_5fplayer_2eproto();

class PlayerInfo;
class CreatePlayer;
class PlayerRank;
class NameMsg;
class DBOfflineEvent;

// ===================================================================

class PlayerInfo : public ::google::protobuf::Message {
 public:
  PlayerInfo();
  virtual ~PlayerInfo();

  PlayerInfo(const PlayerInfo& from);

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInfo& default_instance();

  void Swap(PlayerInfo* other);

  // implements Message ----------------------------------------------

  PlayerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::uint64 charid() const;
  inline void set_charid(::google::protobuf::uint64 value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string charname = 3;
  inline bool has_charname() const;
  inline void clear_charname();
  static const int kCharnameFieldNumber = 3;
  inline const ::std::string& charname() const;
  inline void set_charname(const ::std::string& value);
  inline void set_charname(const char* value);
  inline void set_charname(const char* value, size_t size);
  inline ::std::string* mutable_charname();
  inline ::std::string* release_charname();
  inline void set_allocated_charname(::std::string* charname);

  // optional int32 serverid = 4;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServeridFieldNumber = 4;
  inline ::google::protobuf::int32 serverid() const;
  inline void set_serverid(::google::protobuf::int32 value);

  // optional int32 career = 5;
  inline bool has_career() const;
  inline void clear_career();
  static const int kCareerFieldNumber = 5;
  inline ::google::protobuf::int32 career() const;
  inline void set_career(::google::protobuf::int32 value);

  // optional int32 identity = 6;
  inline bool has_identity() const;
  inline void clear_identity();
  static const int kIdentityFieldNumber = 6;
  inline ::google::protobuf::int32 identity() const;
  inline void set_identity(::google::protobuf::int32 value);

  // optional int32 title = 7;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 7;
  inline ::google::protobuf::int32 title() const;
  inline void set_title(::google::protobuf::int32 value);

  // optional int32 level = 8;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 8;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional uint64 exp = 9;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 9;
  inline ::google::protobuf::uint64 exp() const;
  inline void set_exp(::google::protobuf::uint64 value);

  // optional int32 doubleexp = 10;
  inline bool has_doubleexp() const;
  inline void clear_doubleexp();
  static const int kDoubleexpFieldNumber = 10;
  inline ::google::protobuf::int32 doubleexp() const;
  inline void set_doubleexp(::google::protobuf::int32 value);

  // optional int32 silver_pay = 11;
  inline bool has_silver_pay() const;
  inline void clear_silver_pay();
  static const int kSilverPayFieldNumber = 11;
  inline ::google::protobuf::int32 silver_pay() const;
  inline void set_silver_pay(::google::protobuf::int32 value);

  // optional int32 silver_free = 12;
  inline bool has_silver_free() const;
  inline void clear_silver_free();
  static const int kSilverFreeFieldNumber = 12;
  inline ::google::protobuf::int32 silver_free() const;
  inline void set_silver_free(::google::protobuf::int32 value);

  // optional int32 gold_pay = 13;
  inline bool has_gold_pay() const;
  inline void clear_gold_pay();
  static const int kGoldPayFieldNumber = 13;
  inline ::google::protobuf::int32 gold_pay() const;
  inline void set_gold_pay(::google::protobuf::int32 value);

  // optional int32 gold_free = 14;
  inline bool has_gold_free() const;
  inline void clear_gold_free();
  static const int kGoldFreeFieldNumber = 14;
  inline ::google::protobuf::int32 gold_free() const;
  inline void set_gold_free(::google::protobuf::int32 value);

  // optional int32 diamond_pay = 15;
  inline bool has_diamond_pay() const;
  inline void clear_diamond_pay();
  static const int kDiamondPayFieldNumber = 15;
  inline ::google::protobuf::int32 diamond_pay() const;
  inline void set_diamond_pay(::google::protobuf::int32 value);

  // optional int32 diamond_free = 16;
  inline bool has_diamond_free() const;
  inline void clear_diamond_free();
  static const int kDiamondFreeFieldNumber = 16;
  inline ::google::protobuf::int32 diamond_free() const;
  inline void set_diamond_free(::google::protobuf::int32 value);

  // optional uint32 timestamp = 17;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 17;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // optional uint32 platid = 18;
  inline bool has_platid() const;
  inline void clear_platid();
  static const int kPlatidFieldNumber = 18;
  inline ::google::protobuf::uint32 platid() const;
  inline void set_platid(::google::protobuf::uint32 value);

  // optional string sdkuuid = 19;
  inline bool has_sdkuuid() const;
  inline void clear_sdkuuid();
  static const int kSdkuuidFieldNumber = 19;
  inline const ::std::string& sdkuuid() const;
  inline void set_sdkuuid(const ::std::string& value);
  inline void set_sdkuuid(const char* value);
  inline void set_sdkuuid(const char* value, size_t size);
  inline ::std::string* mutable_sdkuuid();
  inline ::std::string* release_sdkuuid();
  inline void set_allocated_sdkuuid(::std::string* sdkuuid);

  // optional .proto.message.DataInfo data_info = 20;
  inline bool has_data_info() const;
  inline void clear_data_info();
  static const int kDataInfoFieldNumber = 20;
  inline const ::proto::message::DataInfo& data_info() const;
  inline ::proto::message::DataInfo* mutable_data_info();
  inline ::proto::message::DataInfo* release_data_info();
  inline void set_allocated_data_info(::proto::message::DataInfo* data_info);

  // optional .proto.message.AllItemInfo item_info = 21;
  inline bool has_item_info() const;
  inline void clear_item_info();
  static const int kItemInfoFieldNumber = 21;
  inline const ::proto::message::AllItemInfo& item_info() const;
  inline ::proto::message::AllItemInfo* mutable_item_info();
  inline ::proto::message::AllItemInfo* release_item_info();
  inline void set_allocated_item_info(::proto::message::AllItemInfo* item_info);

  // optional .proto.message.EquiponInfo equipon_info = 22;
  inline bool has_equipon_info() const;
  inline void clear_equipon_info();
  static const int kEquiponInfoFieldNumber = 22;
  inline const ::proto::message::EquiponInfo& equipon_info() const;
  inline ::proto::message::EquiponInfo* mutable_equipon_info();
  inline ::proto::message::EquiponInfo* release_equipon_info();
  inline void set_allocated_equipon_info(::proto::message::EquiponInfo* equipon_info);

  // optional .proto.message.AllSkillInfo skill_info = 23;
  inline bool has_skill_info() const;
  inline void clear_skill_info();
  static const int kSkillInfoFieldNumber = 23;
  inline const ::proto::message::AllSkillInfo& skill_info() const;
  inline ::proto::message::AllSkillInfo* mutable_skill_info();
  inline ::proto::message::AllSkillInfo* release_skill_info();
  inline void set_allocated_skill_info(::proto::message::AllSkillInfo* skill_info);

  // optional .proto.message.ProtoAllQuestInfo quest_info = 24;
  inline bool has_quest_info() const;
  inline void clear_quest_info();
  static const int kQuestInfoFieldNumber = 24;
  inline const ::proto::message::ProtoAllQuestInfo& quest_info() const;
  inline ::proto::message::ProtoAllQuestInfo* mutable_quest_info();
  inline ::proto::message::ProtoAllQuestInfo* release_quest_info();
  inline void set_allocated_quest_info(::proto::message::ProtoAllQuestInfo* quest_info);

  // optional .proto.message.ShopInfo shop_info = 25;
  inline bool has_shop_info() const;
  inline void clear_shop_info();
  static const int kShopInfoFieldNumber = 25;
  inline const ::proto::message::ShopInfo& shop_info() const;
  inline ::proto::message::ShopInfo* mutable_shop_info();
  inline ::proto::message::ShopInfo* release_shop_info();
  inline void set_allocated_shop_info(::proto::message::ShopInfo* shop_info);

  // optional .proto.message.AllTalentInfo talent_info = 27;
  inline bool has_talent_info() const;
  inline void clear_talent_info();
  static const int kTalentInfoFieldNumber = 27;
  inline const ::proto::message::AllTalentInfo& talent_info() const;
  inline ::proto::message::AllTalentInfo* mutable_talent_info();
  inline ::proto::message::AllTalentInfo* release_talent_info();
  inline void set_allocated_talent_info(::proto::message::AllTalentInfo* talent_info);

  // optional .proto.message.ProtoAllFriendInfo friend_info = 28;
  inline bool has_friend_info() const;
  inline void clear_friend_info();
  static const int kFriendInfoFieldNumber = 28;
  inline const ::proto::message::ProtoAllFriendInfo& friend_info() const;
  inline ::proto::message::ProtoAllFriendInfo* mutable_friend_info();
  inline ::proto::message::ProtoAllFriendInfo* release_friend_info();
  inline void set_allocated_friend_info(::proto::message::ProtoAllFriendInfo* friend_info);

  // optional .proto.message.DungeonInfo dungeon_info = 29;
  inline bool has_dungeon_info() const;
  inline void clear_dungeon_info();
  static const int kDungeonInfoFieldNumber = 29;
  inline const ::proto::message::DungeonInfo& dungeon_info() const;
  inline ::proto::message::DungeonInfo* mutable_dungeon_info();
  inline ::proto::message::DungeonInfo* release_dungeon_info();
  inline void set_allocated_dungeon_info(::proto::message::DungeonInfo* dungeon_info);

  // optional .proto.message.ActivityInfo activity_info = 30;
  inline bool has_activity_info() const;
  inline void clear_activity_info();
  static const int kActivityInfoFieldNumber = 30;
  inline const ::proto::message::ActivityInfo& activity_info() const;
  inline ::proto::message::ActivityInfo* mutable_activity_info();
  inline ::proto::message::ActivityInfo* release_activity_info();
  inline void set_allocated_activity_info(::proto::message::ActivityInfo* activity_info);

  // optional .proto.message.PlayerLivelyInfo lively_info = 31;
  inline bool has_lively_info() const;
  inline void clear_lively_info();
  static const int kLivelyInfoFieldNumber = 31;
  inline const ::proto::message::PlayerLivelyInfo& lively_info() const;
  inline ::proto::message::PlayerLivelyInfo* mutable_lively_info();
  inline ::proto::message::PlayerLivelyInfo* release_lively_info();
  inline void set_allocated_lively_info(::proto::message::PlayerLivelyInfo* lively_info);

  // optional .proto.message.TitleData title_info = 32;
  inline bool has_title_info() const;
  inline void clear_title_info();
  static const int kTitleInfoFieldNumber = 32;
  inline const ::proto::message::TitleData& title_info() const;
  inline ::proto::message::TitleData* mutable_title_info();
  inline ::proto::message::TitleData* release_title_info();
  inline void set_allocated_title_info(::proto::message::TitleData* title_info);

  // optional .proto.message.WelfareInfo welfare_info = 33;
  inline bool has_welfare_info() const;
  inline void clear_welfare_info();
  static const int kWelfareInfoFieldNumber = 33;
  inline const ::proto::message::WelfareInfo& welfare_info() const;
  inline ::proto::message::WelfareInfo* mutable_welfare_info();
  inline ::proto::message::WelfareInfo* release_welfare_info();
  inline void set_allocated_welfare_info(::proto::message::WelfareInfo* welfare_info);

  // optional .proto.message.DBAchieveInfo achieve_info = 34;
  inline bool has_achieve_info() const;
  inline void clear_achieve_info();
  static const int kAchieveInfoFieldNumber = 34;
  inline const ::proto::message::DBAchieveInfo& achieve_info() const;
  inline ::proto::message::DBAchieveInfo* mutable_achieve_info();
  inline ::proto::message::DBAchieveInfo* release_achieve_info();
  inline void set_allocated_achieve_info(::proto::message::DBAchieveInfo* achieve_info);

  // optional .proto.message.ProtoGodWeaponAllCellInfo godweapon_info = 35;
  inline bool has_godweapon_info() const;
  inline void clear_godweapon_info();
  static const int kGodweaponInfoFieldNumber = 35;
  inline const ::proto::message::ProtoGodWeaponAllCellInfo& godweapon_info() const;
  inline ::proto::message::ProtoGodWeaponAllCellInfo* mutable_godweapon_info();
  inline ::proto::message::ProtoGodWeaponAllCellInfo* release_godweapon_info();
  inline void set_allocated_godweapon_info(::proto::message::ProtoGodWeaponAllCellInfo* godweapon_info);

  // optional .proto.message.ProtoRideAllCellInfo ride_info = 36;
  inline bool has_ride_info() const;
  inline void clear_ride_info();
  static const int kRideInfoFieldNumber = 36;
  inline const ::proto::message::ProtoRideAllCellInfo& ride_info() const;
  inline ::proto::message::ProtoRideAllCellInfo* mutable_ride_info();
  inline ::proto::message::ProtoRideAllCellInfo* release_ride_info();
  inline void set_allocated_ride_info(::proto::message::ProtoRideAllCellInfo* ride_info);

  // optional .proto.message.ProtoPetAllCellInfo pet_info = 37;
  inline bool has_pet_info() const;
  inline void clear_pet_info();
  static const int kPetInfoFieldNumber = 37;
  inline const ::proto::message::ProtoPetAllCellInfo& pet_info() const;
  inline ::proto::message::ProtoPetAllCellInfo* mutable_pet_info();
  inline ::proto::message::ProtoPetAllCellInfo* release_pet_info();
  inline void set_allocated_pet_info(::proto::message::ProtoPetAllCellInfo* pet_info);

  // optional .proto.message.ProtoAwakenAllCellInfo awaken_info = 38;
  inline bool has_awaken_info() const;
  inline void clear_awaken_info();
  static const int kAwakenInfoFieldNumber = 38;
  inline const ::proto::message::ProtoAwakenAllCellInfo& awaken_info() const;
  inline ::proto::message::ProtoAwakenAllCellInfo* mutable_awaken_info();
  inline ::proto::message::ProtoAwakenAllCellInfo* release_awaken_info();
  inline void set_allocated_awaken_info(::proto::message::ProtoAwakenAllCellInfo* awaken_info);

  // optional .proto.message.BoatAllData boat_info = 39;
  inline bool has_boat_info() const;
  inline void clear_boat_info();
  static const int kBoatInfoFieldNumber = 39;
  inline const ::proto::message::BoatAllData& boat_info() const;
  inline ::proto::message::BoatAllData* mutable_boat_info();
  inline ::proto::message::BoatAllData* release_boat_info();
  inline void set_allocated_boat_info(::proto::message::BoatAllData* boat_info);

  // optional .proto.message.ProtoMerAllCellInfo mercenary_info = 40;
  inline bool has_mercenary_info() const;
  inline void clear_mercenary_info();
  static const int kMercenaryInfoFieldNumber = 40;
  inline const ::proto::message::ProtoMerAllCellInfo& mercenary_info() const;
  inline ::proto::message::ProtoMerAllCellInfo* mutable_mercenary_info();
  inline ::proto::message::ProtoMerAllCellInfo* release_mercenary_info();
  inline void set_allocated_mercenary_info(::proto::message::ProtoMerAllCellInfo* mercenary_info);

  // optional .proto.message.ProtoAllSevenDayTargetInfo sevenday_info = 41;
  inline bool has_sevenday_info() const;
  inline void clear_sevenday_info();
  static const int kSevendayInfoFieldNumber = 41;
  inline const ::proto::message::ProtoAllSevenDayTargetInfo& sevenday_info() const;
  inline ::proto::message::ProtoAllSevenDayTargetInfo* mutable_sevenday_info();
  inline ::proto::message::ProtoAllSevenDayTargetInfo* release_sevenday_info();
  inline void set_allocated_sevenday_info(::proto::message::ProtoAllSevenDayTargetInfo* sevenday_info);

  // optional .proto.message.Potential sPotential = 42;
  inline bool has_spotential() const;
  inline void clear_spotential();
  static const int kSPotentialFieldNumber = 42;
  inline const ::proto::message::Potential& spotential() const;
  inline ::proto::message::Potential* mutable_spotential();
  inline ::proto::message::Potential* release_spotential();
  inline void set_allocated_spotential(::proto::message::Potential* spotential);

  // optional .proto.message.VIPInfo vip_info = 43;
  inline bool has_vip_info() const;
  inline void clear_vip_info();
  static const int kVipInfoFieldNumber = 43;
  inline const ::proto::message::VIPInfo& vip_info() const;
  inline ::proto::message::VIPInfo* mutable_vip_info();
  inline ::proto::message::VIPInfo* release_vip_info();
  inline void set_allocated_vip_info(::proto::message::VIPInfo* vip_info);

  // optional .proto.message.ProtoAllProgressConInfo progresscon_info = 44;
  inline bool has_progresscon_info() const;
  inline void clear_progresscon_info();
  static const int kProgressconInfoFieldNumber = 44;
  inline const ::proto::message::ProtoAllProgressConInfo& progresscon_info() const;
  inline ::proto::message::ProtoAllProgressConInfo* mutable_progresscon_info();
  inline ::proto::message::ProtoAllProgressConInfo* release_progresscon_info();
  inline void set_allocated_progresscon_info(::proto::message::ProtoAllProgressConInfo* progresscon_info);

  // optional .proto.message.ProtoAllInvestmentInfo investment_info = 45;
  inline bool has_investment_info() const;
  inline void clear_investment_info();
  static const int kInvestmentInfoFieldNumber = 45;
  inline const ::proto::message::ProtoAllInvestmentInfo& investment_info() const;
  inline ::proto::message::ProtoAllInvestmentInfo* mutable_investment_info();
  inline ::proto::message::ProtoAllInvestmentInfo* release_investment_info();
  inline void set_allocated_investment_info(::proto::message::ProtoAllInvestmentInfo* investment_info);

  // optional .proto.message.ProtoAllDailyFirstChargeInfo dailycharge_info = 46;
  inline bool has_dailycharge_info() const;
  inline void clear_dailycharge_info();
  static const int kDailychargeInfoFieldNumber = 46;
  inline const ::proto::message::ProtoAllDailyFirstChargeInfo& dailycharge_info() const;
  inline ::proto::message::ProtoAllDailyFirstChargeInfo* mutable_dailycharge_info();
  inline ::proto::message::ProtoAllDailyFirstChargeInfo* release_dailycharge_info();
  inline void set_allocated_dailycharge_info(::proto::message::ProtoAllDailyFirstChargeInfo* dailycharge_info);

  // optional .proto.message.ProtoAllLimitChargeInfo limitcharge_info = 47;
  inline bool has_limitcharge_info() const;
  inline void clear_limitcharge_info();
  static const int kLimitchargeInfoFieldNumber = 47;
  inline const ::proto::message::ProtoAllLimitChargeInfo& limitcharge_info() const;
  inline ::proto::message::ProtoAllLimitChargeInfo* mutable_limitcharge_info();
  inline ::proto::message::ProtoAllLimitChargeInfo* release_limitcharge_info();
  inline void set_allocated_limitcharge_info(::proto::message::ProtoAllLimitChargeInfo* limitcharge_info);

  // optional .proto.message.ProtoAllChargeBigGiftInfo chargebiggift_info = 48;
  inline bool has_chargebiggift_info() const;
  inline void clear_chargebiggift_info();
  static const int kChargebiggiftInfoFieldNumber = 48;
  inline const ::proto::message::ProtoAllChargeBigGiftInfo& chargebiggift_info() const;
  inline ::proto::message::ProtoAllChargeBigGiftInfo* mutable_chargebiggift_info();
  inline ::proto::message::ProtoAllChargeBigGiftInfo* release_chargebiggift_info();
  inline void set_allocated_chargebiggift_info(::proto::message::ProtoAllChargeBigGiftInfo* chargebiggift_info);

  // optional .proto.message.ContinuousChargeInfo continuouscharge_info = 49;
  inline bool has_continuouscharge_info() const;
  inline void clear_continuouscharge_info();
  static const int kContinuouschargeInfoFieldNumber = 49;
  inline const ::proto::message::ContinuousChargeInfo& continuouscharge_info() const;
  inline ::proto::message::ContinuousChargeInfo* mutable_continuouscharge_info();
  inline ::proto::message::ContinuousChargeInfo* release_continuouscharge_info();
  inline void set_allocated_continuouscharge_info(::proto::message::ContinuousChargeInfo* continuouscharge_info);

  // optional .proto.message.SpecialSaleInfo specialsale_info = 50;
  inline bool has_specialsale_info() const;
  inline void clear_specialsale_info();
  static const int kSpecialsaleInfoFieldNumber = 50;
  inline const ::proto::message::SpecialSaleInfo& specialsale_info() const;
  inline ::proto::message::SpecialSaleInfo* mutable_specialsale_info();
  inline ::proto::message::SpecialSaleInfo* release_specialsale_info();
  inline void set_allocated_specialsale_info(::proto::message::SpecialSaleInfo* specialsale_info);

  // optional .proto.message.LostTreasureInfo losttreasure_info = 51;
  inline bool has_losttreasure_info() const;
  inline void clear_losttreasure_info();
  static const int kLosttreasureInfoFieldNumber = 51;
  inline const ::proto::message::LostTreasureInfo& losttreasure_info() const;
  inline ::proto::message::LostTreasureInfo* mutable_losttreasure_info();
  inline ::proto::message::LostTreasureInfo* release_losttreasure_info();
  inline void set_allocated_losttreasure_info(::proto::message::LostTreasureInfo* losttreasure_info);

  // optional .proto.message.MoneyTreeInfo moneytree_info = 52;
  inline bool has_moneytree_info() const;
  inline void clear_moneytree_info();
  static const int kMoneytreeInfoFieldNumber = 52;
  inline const ::proto::message::MoneyTreeInfo& moneytree_info() const;
  inline ::proto::message::MoneyTreeInfo* mutable_moneytree_info();
  inline ::proto::message::MoneyTreeInfo* release_moneytree_info();
  inline void set_allocated_moneytree_info(::proto::message::MoneyTreeInfo* moneytree_info);

  // optional .proto.message.DiscountStoreInfo discountstore_info = 53;
  inline bool has_discountstore_info() const;
  inline void clear_discountstore_info();
  static const int kDiscountstoreInfoFieldNumber = 53;
  inline const ::proto::message::DiscountStoreInfo& discountstore_info() const;
  inline ::proto::message::DiscountStoreInfo* mutable_discountstore_info();
  inline ::proto::message::DiscountStoreInfo* release_discountstore_info();
  inline void set_allocated_discountstore_info(::proto::message::DiscountStoreInfo* discountstore_info);

  // @@protoc_insertion_point(class_scope:proto.message.PlayerInfo)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_charname();
  inline void clear_has_charname();
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_career();
  inline void clear_has_career();
  inline void set_has_identity();
  inline void clear_has_identity();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_doubleexp();
  inline void clear_has_doubleexp();
  inline void set_has_silver_pay();
  inline void clear_has_silver_pay();
  inline void set_has_silver_free();
  inline void clear_has_silver_free();
  inline void set_has_gold_pay();
  inline void clear_has_gold_pay();
  inline void set_has_gold_free();
  inline void clear_has_gold_free();
  inline void set_has_diamond_pay();
  inline void clear_has_diamond_pay();
  inline void set_has_diamond_free();
  inline void clear_has_diamond_free();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_platid();
  inline void clear_has_platid();
  inline void set_has_sdkuuid();
  inline void clear_has_sdkuuid();
  inline void set_has_data_info();
  inline void clear_has_data_info();
  inline void set_has_item_info();
  inline void clear_has_item_info();
  inline void set_has_equipon_info();
  inline void clear_has_equipon_info();
  inline void set_has_skill_info();
  inline void clear_has_skill_info();
  inline void set_has_quest_info();
  inline void clear_has_quest_info();
  inline void set_has_shop_info();
  inline void clear_has_shop_info();
  inline void set_has_talent_info();
  inline void clear_has_talent_info();
  inline void set_has_friend_info();
  inline void clear_has_friend_info();
  inline void set_has_dungeon_info();
  inline void clear_has_dungeon_info();
  inline void set_has_activity_info();
  inline void clear_has_activity_info();
  inline void set_has_lively_info();
  inline void clear_has_lively_info();
  inline void set_has_title_info();
  inline void clear_has_title_info();
  inline void set_has_welfare_info();
  inline void clear_has_welfare_info();
  inline void set_has_achieve_info();
  inline void clear_has_achieve_info();
  inline void set_has_godweapon_info();
  inline void clear_has_godweapon_info();
  inline void set_has_ride_info();
  inline void clear_has_ride_info();
  inline void set_has_pet_info();
  inline void clear_has_pet_info();
  inline void set_has_awaken_info();
  inline void clear_has_awaken_info();
  inline void set_has_boat_info();
  inline void clear_has_boat_info();
  inline void set_has_mercenary_info();
  inline void clear_has_mercenary_info();
  inline void set_has_sevenday_info();
  inline void clear_has_sevenday_info();
  inline void set_has_spotential();
  inline void clear_has_spotential();
  inline void set_has_vip_info();
  inline void clear_has_vip_info();
  inline void set_has_progresscon_info();
  inline void clear_has_progresscon_info();
  inline void set_has_investment_info();
  inline void clear_has_investment_info();
  inline void set_has_dailycharge_info();
  inline void clear_has_dailycharge_info();
  inline void set_has_limitcharge_info();
  inline void clear_has_limitcharge_info();
  inline void set_has_chargebiggift_info();
  inline void clear_has_chargebiggift_info();
  inline void set_has_continuouscharge_info();
  inline void clear_has_continuouscharge_info();
  inline void set_has_specialsale_info();
  inline void clear_has_specialsale_info();
  inline void set_has_losttreasure_info();
  inline void clear_has_losttreasure_info();
  inline void set_has_moneytree_info();
  inline void clear_has_moneytree_info();
  inline void set_has_discountstore_info();
  inline void clear_has_discountstore_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 charid_;
  ::std::string* account_;
  ::std::string* charname_;
  ::google::protobuf::int32 serverid_;
  ::google::protobuf::int32 career_;
  ::google::protobuf::int32 identity_;
  ::google::protobuf::int32 title_;
  ::google::protobuf::uint64 exp_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 doubleexp_;
  ::google::protobuf::int32 silver_pay_;
  ::google::protobuf::int32 silver_free_;
  ::google::protobuf::int32 gold_pay_;
  ::google::protobuf::int32 gold_free_;
  ::google::protobuf::int32 diamond_pay_;
  ::google::protobuf::int32 diamond_free_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 platid_;
  ::std::string* sdkuuid_;
  ::proto::message::DataInfo* data_info_;
  ::proto::message::AllItemInfo* item_info_;
  ::proto::message::EquiponInfo* equipon_info_;
  ::proto::message::AllSkillInfo* skill_info_;
  ::proto::message::ProtoAllQuestInfo* quest_info_;
  ::proto::message::ShopInfo* shop_info_;
  ::proto::message::AllTalentInfo* talent_info_;
  ::proto::message::ProtoAllFriendInfo* friend_info_;
  ::proto::message::DungeonInfo* dungeon_info_;
  ::proto::message::ActivityInfo* activity_info_;
  ::proto::message::PlayerLivelyInfo* lively_info_;
  ::proto::message::TitleData* title_info_;
  ::proto::message::WelfareInfo* welfare_info_;
  ::proto::message::DBAchieveInfo* achieve_info_;
  ::proto::message::ProtoGodWeaponAllCellInfo* godweapon_info_;
  ::proto::message::ProtoRideAllCellInfo* ride_info_;
  ::proto::message::ProtoPetAllCellInfo* pet_info_;
  ::proto::message::ProtoAwakenAllCellInfo* awaken_info_;
  ::proto::message::BoatAllData* boat_info_;
  ::proto::message::ProtoMerAllCellInfo* mercenary_info_;
  ::proto::message::ProtoAllSevenDayTargetInfo* sevenday_info_;
  ::proto::message::Potential* spotential_;
  ::proto::message::VIPInfo* vip_info_;
  ::proto::message::ProtoAllProgressConInfo* progresscon_info_;
  ::proto::message::ProtoAllInvestmentInfo* investment_info_;
  ::proto::message::ProtoAllDailyFirstChargeInfo* dailycharge_info_;
  ::proto::message::ProtoAllLimitChargeInfo* limitcharge_info_;
  ::proto::message::ProtoAllChargeBigGiftInfo* chargebiggift_info_;
  ::proto::message::ContinuousChargeInfo* continuouscharge_info_;
  ::proto::message::SpecialSaleInfo* specialsale_info_;
  ::proto::message::LostTreasureInfo* losttreasure_info_;
  ::proto::message::MoneyTreeInfo* moneytree_info_;
  ::proto::message::DiscountStoreInfo* discountstore_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(52 + 31) / 32];

  friend void  protobuf_AddDesc_db_5fplayer_2eproto();
  friend void protobuf_AssignDesc_db_5fplayer_2eproto();
  friend void protobuf_ShutdownFile_db_5fplayer_2eproto();

  void InitAsDefaultInstance();
  static PlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class CreatePlayer : public ::google::protobuf::Message {
 public:
  CreatePlayer();
  virtual ~CreatePlayer();

  CreatePlayer(const CreatePlayer& from);

  inline CreatePlayer& operator=(const CreatePlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreatePlayer& default_instance();

  void Swap(CreatePlayer* other);

  // implements Message ----------------------------------------------

  CreatePlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreatePlayer& from);
  void MergeFrom(const CreatePlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::uint64 charid() const;
  inline void set_charid(::google::protobuf::uint64 value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string charname = 3;
  inline bool has_charname() const;
  inline void clear_charname();
  static const int kCharnameFieldNumber = 3;
  inline const ::std::string& charname() const;
  inline void set_charname(const ::std::string& value);
  inline void set_charname(const char* value);
  inline void set_charname(const char* value, size_t size);
  inline ::std::string* mutable_charname();
  inline ::std::string* release_charname();
  inline void set_allocated_charname(::std::string* charname);

  // optional int32 server_id = 4;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 4;
  inline ::google::protobuf::int32 server_id() const;
  inline void set_server_id(::google::protobuf::int32 value);

  // optional int32 sex = 5;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 5;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // optional int32 career = 6;
  inline bool has_career() const;
  inline void clear_career();
  static const int kCareerFieldNumber = 6;
  inline ::google::protobuf::int32 career() const;
  inline void set_career(::google::protobuf::int32 value);

  // optional int32 plat_id = 7;
  inline bool has_plat_id() const;
  inline void clear_plat_id();
  static const int kPlatIdFieldNumber = 7;
  inline ::google::protobuf::int32 plat_id() const;
  inline void set_plat_id(::google::protobuf::int32 value);

  // optional string sdk_uuid = 8;
  inline bool has_sdk_uuid() const;
  inline void clear_sdk_uuid();
  static const int kSdkUuidFieldNumber = 8;
  inline const ::std::string& sdk_uuid() const;
  inline void set_sdk_uuid(const ::std::string& value);
  inline void set_sdk_uuid(const char* value);
  inline void set_sdk_uuid(const char* value, size_t size);
  inline ::std::string* mutable_sdk_uuid();
  inline ::std::string* release_sdk_uuid();
  inline void set_allocated_sdk_uuid(::std::string* sdk_uuid);

  // @@protoc_insertion_point(class_scope:proto.message.CreatePlayer)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_charname();
  inline void clear_has_charname();
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_career();
  inline void clear_has_career();
  inline void set_has_plat_id();
  inline void clear_has_plat_id();
  inline void set_has_sdk_uuid();
  inline void clear_has_sdk_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 charid_;
  ::std::string* account_;
  ::std::string* charname_;
  ::google::protobuf::int32 server_id_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 career_;
  ::google::protobuf::int32 plat_id_;
  ::std::string* sdk_uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_db_5fplayer_2eproto();
  friend void protobuf_AssignDesc_db_5fplayer_2eproto();
  friend void protobuf_ShutdownFile_db_5fplayer_2eproto();

  void InitAsDefaultInstance();
  static CreatePlayer* default_instance_;
};
// -------------------------------------------------------------------

class PlayerRank : public ::google::protobuf::Message {
 public:
  PlayerRank();
  virtual ~PlayerRank();

  PlayerRank(const PlayerRank& from);

  inline PlayerRank& operator=(const PlayerRank& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerRank& default_instance();

  void Swap(PlayerRank* other);

  // implements Message ----------------------------------------------

  PlayerRank* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerRank& from);
  void MergeFrom(const PlayerRank& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::uint64 charid() const;
  inline void set_charid(::google::protobuf::uint64 value);

  // optional string charname = 2;
  inline bool has_charname() const;
  inline void clear_charname();
  static const int kCharnameFieldNumber = 2;
  inline const ::std::string& charname() const;
  inline void set_charname(const ::std::string& value);
  inline void set_charname(const char* value);
  inline void set_charname(const char* value, size_t size);
  inline ::std::string* mutable_charname();
  inline ::std::string* release_charname();
  inline void set_allocated_charname(::std::string* charname);

  // optional int32 career = 3;
  inline bool has_career() const;
  inline void clear_career();
  static const int kCareerFieldNumber = 3;
  inline ::google::protobuf::int32 career() const;
  inline void set_career(::google::protobuf::int32 value);

  // optional int32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 pvp_score = 5;
  inline bool has_pvp_score() const;
  inline void clear_pvp_score();
  static const int kPvpScoreFieldNumber = 5;
  inline ::google::protobuf::int32 pvp_score() const;
  inline void set_pvp_score(::google::protobuf::int32 value);

  // optional int32 pvp_num = 6;
  inline bool has_pvp_num() const;
  inline void clear_pvp_num();
  static const int kPvpNumFieldNumber = 6;
  inline ::google::protobuf::int32 pvp_num() const;
  inline void set_pvp_num(::google::protobuf::int32 value);

  // optional .proto.message.PVPInfo pvp_info = 7;
  inline bool has_pvp_info() const;
  inline void clear_pvp_info();
  static const int kPvpInfoFieldNumber = 7;
  inline const ::proto::message::PVPInfo& pvp_info() const;
  inline ::proto::message::PVPInfo* mutable_pvp_info();
  inline ::proto::message::PVPInfo* release_pvp_info();
  inline void set_allocated_pvp_info(::proto::message::PVPInfo* pvp_info);

  // optional int32 arena_score = 8;
  inline bool has_arena_score() const;
  inline void clear_arena_score();
  static const int kArenaScoreFieldNumber = 8;
  inline ::google::protobuf::int32 arena_score() const;
  inline void set_arena_score(::google::protobuf::int32 value);

  // optional int32 arena_stage = 9;
  inline bool has_arena_stage() const;
  inline void clear_arena_stage();
  static const int kArenaStageFieldNumber = 9;
  inline ::google::protobuf::int32 arena_stage() const;
  inline void set_arena_stage(::google::protobuf::int32 value);

  // optional .proto.message.ArenaInfo arena_info = 10;
  inline bool has_arena_info() const;
  inline void clear_arena_info();
  static const int kArenaInfoFieldNumber = 10;
  inline const ::proto::message::ArenaInfo& arena_info() const;
  inline ::proto::message::ArenaInfo* mutable_arena_info();
  inline ::proto::message::ArenaInfo* release_arena_info();
  inline void set_allocated_arena_info(::proto::message::ArenaInfo* arena_info);

  // optional int32 boat_pvp_score = 11;
  inline bool has_boat_pvp_score() const;
  inline void clear_boat_pvp_score();
  static const int kBoatPvpScoreFieldNumber = 11;
  inline ::google::protobuf::int32 boat_pvp_score() const;
  inline void set_boat_pvp_score(::google::protobuf::int32 value);

  // optional int32 boat_pvp_num = 12;
  inline bool has_boat_pvp_num() const;
  inline void clear_boat_pvp_num();
  static const int kBoatPvpNumFieldNumber = 12;
  inline ::google::protobuf::int32 boat_pvp_num() const;
  inline void set_boat_pvp_num(::google::protobuf::int32 value);

  // optional .proto.message.PVPInfo boat_pvp_info = 13;
  inline bool has_boat_pvp_info() const;
  inline void clear_boat_pvp_info();
  static const int kBoatPvpInfoFieldNumber = 13;
  inline const ::proto::message::PVPInfo& boat_pvp_info() const;
  inline ::proto::message::PVPInfo* mutable_boat_pvp_info();
  inline ::proto::message::PVPInfo* release_boat_pvp_info();
  inline void set_allocated_boat_pvp_info(::proto::message::PVPInfo* boat_pvp_info);

  // @@protoc_insertion_point(class_scope:proto.message.PlayerRank)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_charname();
  inline void clear_has_charname();
  inline void set_has_career();
  inline void clear_has_career();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_pvp_score();
  inline void clear_has_pvp_score();
  inline void set_has_pvp_num();
  inline void clear_has_pvp_num();
  inline void set_has_pvp_info();
  inline void clear_has_pvp_info();
  inline void set_has_arena_score();
  inline void clear_has_arena_score();
  inline void set_has_arena_stage();
  inline void clear_has_arena_stage();
  inline void set_has_arena_info();
  inline void clear_has_arena_info();
  inline void set_has_boat_pvp_score();
  inline void clear_has_boat_pvp_score();
  inline void set_has_boat_pvp_num();
  inline void clear_has_boat_pvp_num();
  inline void set_has_boat_pvp_info();
  inline void clear_has_boat_pvp_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 charid_;
  ::std::string* charname_;
  ::google::protobuf::int32 career_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 pvp_score_;
  ::google::protobuf::int32 pvp_num_;
  ::proto::message::PVPInfo* pvp_info_;
  ::google::protobuf::int32 arena_score_;
  ::google::protobuf::int32 arena_stage_;
  ::proto::message::ArenaInfo* arena_info_;
  ::google::protobuf::int32 boat_pvp_score_;
  ::google::protobuf::int32 boat_pvp_num_;
  ::proto::message::PVPInfo* boat_pvp_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_db_5fplayer_2eproto();
  friend void protobuf_AssignDesc_db_5fplayer_2eproto();
  friend void protobuf_ShutdownFile_db_5fplayer_2eproto();

  void InitAsDefaultInstance();
  static PlayerRank* default_instance_;
};
// -------------------------------------------------------------------

class NameMsg : public ::google::protobuf::Message {
 public:
  NameMsg();
  virtual ~NameMsg();

  NameMsg(const NameMsg& from);

  inline NameMsg& operator=(const NameMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameMsg& default_instance();

  void Swap(NameMsg* other);

  // implements Message ----------------------------------------------

  NameMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameMsg& from);
  void MergeFrom(const NameMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::uint64 charid() const;
  inline void set_charid(::google::protobuf::uint64 value);

  // optional string charname = 2;
  inline bool has_charname() const;
  inline void clear_charname();
  static const int kCharnameFieldNumber = 2;
  inline const ::std::string& charname() const;
  inline void set_charname(const ::std::string& value);
  inline void set_charname(const char* value);
  inline void set_charname(const char* value, size_t size);
  inline ::std::string* mutable_charname();
  inline ::std::string* release_charname();
  inline void set_allocated_charname(::std::string* charname);

  // @@protoc_insertion_point(class_scope:proto.message.NameMsg)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_charname();
  inline void clear_has_charname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 charid_;
  ::std::string* charname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_db_5fplayer_2eproto();
  friend void protobuf_AssignDesc_db_5fplayer_2eproto();
  friend void protobuf_ShutdownFile_db_5fplayer_2eproto();

  void InitAsDefaultInstance();
  static NameMsg* default_instance_;
};
// -------------------------------------------------------------------

class DBOfflineEvent : public ::google::protobuf::Message {
 public:
  DBOfflineEvent();
  virtual ~DBOfflineEvent();

  DBOfflineEvent(const DBOfflineEvent& from);

  inline DBOfflineEvent& operator=(const DBOfflineEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBOfflineEvent& default_instance();

  void Swap(DBOfflineEvent* other);

  // implements Message ----------------------------------------------

  DBOfflineEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DBOfflineEvent& from);
  void MergeFrom(const DBOfflineEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eventid = 1;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventidFieldNumber = 1;
  inline ::google::protobuf::uint32 eventid() const;
  inline void set_eventid(::google::protobuf::uint32 value);

  // optional int32 eventtype = 2;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventtypeFieldNumber = 2;
  inline ::google::protobuf::int32 eventtype() const;
  inline void set_eventtype(::google::protobuf::int32 value);

  // optional uint64 fromply = 3;
  inline bool has_fromply() const;
  inline void clear_fromply();
  static const int kFromplyFieldNumber = 3;
  inline ::google::protobuf::uint64 fromply() const;
  inline void set_fromply(::google::protobuf::uint64 value);

  // optional uint64 toply = 4;
  inline bool has_toply() const;
  inline void clear_toply();
  static const int kToplyFieldNumber = 4;
  inline ::google::protobuf::uint64 toply() const;
  inline void set_toply(::google::protobuf::uint64 value);

  // optional int32 eventstate = 5;
  inline bool has_eventstate() const;
  inline void clear_eventstate();
  static const int kEventstateFieldNumber = 5;
  inline ::google::protobuf::int32 eventstate() const;
  inline void set_eventstate(::google::protobuf::int32 value);

  // optional int32 intparam1 = 6;
  inline bool has_intparam1() const;
  inline void clear_intparam1();
  static const int kIntparam1FieldNumber = 6;
  inline ::google::protobuf::int32 intparam1() const;
  inline void set_intparam1(::google::protobuf::int32 value);

  // optional int32 intparam2 = 7;
  inline bool has_intparam2() const;
  inline void clear_intparam2();
  static const int kIntparam2FieldNumber = 7;
  inline ::google::protobuf::int32 intparam2() const;
  inline void set_intparam2(::google::protobuf::int32 value);

  // optional string strparam1 = 8;
  inline bool has_strparam1() const;
  inline void clear_strparam1();
  static const int kStrparam1FieldNumber = 8;
  inline const ::std::string& strparam1() const;
  inline void set_strparam1(const ::std::string& value);
  inline void set_strparam1(const char* value);
  inline void set_strparam1(const char* value, size_t size);
  inline ::std::string* mutable_strparam1();
  inline ::std::string* release_strparam1();
  inline void set_allocated_strparam1(::std::string* strparam1);

  // optional string strparam2 = 9;
  inline bool has_strparam2() const;
  inline void clear_strparam2();
  static const int kStrparam2FieldNumber = 9;
  inline const ::std::string& strparam2() const;
  inline void set_strparam2(const ::std::string& value);
  inline void set_strparam2(const char* value);
  inline void set_strparam2(const char* value, size_t size);
  inline ::std::string* mutable_strparam2();
  inline ::std::string* release_strparam2();
  inline void set_allocated_strparam2(::std::string* strparam2);

  // optional uint64 timetick = 10;
  inline bool has_timetick() const;
  inline void clear_timetick();
  static const int kTimetickFieldNumber = 10;
  inline ::google::protobuf::uint64 timetick() const;
  inline void set_timetick(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.message.DBOfflineEvent)
 private:
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_fromply();
  inline void clear_has_fromply();
  inline void set_has_toply();
  inline void clear_has_toply();
  inline void set_has_eventstate();
  inline void clear_has_eventstate();
  inline void set_has_intparam1();
  inline void clear_has_intparam1();
  inline void set_has_intparam2();
  inline void clear_has_intparam2();
  inline void set_has_strparam1();
  inline void clear_has_strparam1();
  inline void set_has_strparam2();
  inline void clear_has_strparam2();
  inline void set_has_timetick();
  inline void clear_has_timetick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 eventid_;
  ::google::protobuf::int32 eventtype_;
  ::google::protobuf::uint64 fromply_;
  ::google::protobuf::uint64 toply_;
  ::google::protobuf::int32 eventstate_;
  ::google::protobuf::int32 intparam1_;
  ::std::string* strparam1_;
  ::std::string* strparam2_;
  ::google::protobuf::uint64 timetick_;
  ::google::protobuf::int32 intparam2_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_db_5fplayer_2eproto();
  friend void protobuf_AssignDesc_db_5fplayer_2eproto();
  friend void protobuf_ShutdownFile_db_5fplayer_2eproto();

  void InitAsDefaultInstance();
  static DBOfflineEvent* default_instance_;
};
// ===================================================================


// ===================================================================

// PlayerInfo

// optional uint64 charid = 1;
inline bool PlayerInfo::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerInfo::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerInfo::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerInfo::clear_charid() {
  charid_ = GOOGLE_ULONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::uint64 PlayerInfo::charid() const {
  return charid_;
}
inline void PlayerInfo::set_charid(::google::protobuf::uint64 value) {
  set_has_charid();
  charid_ = value;
}

// optional string account = 2;
inline bool PlayerInfo::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerInfo::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerInfo::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerInfo::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& PlayerInfo::account() const {
  return *account_;
}
inline void PlayerInfo::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void PlayerInfo::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void PlayerInfo::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerInfo::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* PlayerInfo::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerInfo::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string charname = 3;
inline bool PlayerInfo::has_charname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerInfo::set_has_charname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerInfo::clear_has_charname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerInfo::clear_charname() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    charname_->clear();
  }
  clear_has_charname();
}
inline const ::std::string& PlayerInfo::charname() const {
  return *charname_;
}
inline void PlayerInfo::set_charname(const ::std::string& value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void PlayerInfo::set_charname(const char* value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void PlayerInfo::set_charname(const char* value, size_t size) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerInfo::mutable_charname() {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  return charname_;
}
inline ::std::string* PlayerInfo::release_charname() {
  clear_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charname_;
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerInfo::set_allocated_charname(::std::string* charname) {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  if (charname) {
    set_has_charname();
    charname_ = charname;
  } else {
    clear_has_charname();
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 serverid = 4;
inline bool PlayerInfo::has_serverid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerInfo::set_has_serverid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerInfo::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerInfo::clear_serverid() {
  serverid_ = 0;
  clear_has_serverid();
}
inline ::google::protobuf::int32 PlayerInfo::serverid() const {
  return serverid_;
}
inline void PlayerInfo::set_serverid(::google::protobuf::int32 value) {
  set_has_serverid();
  serverid_ = value;
}

// optional int32 career = 5;
inline bool PlayerInfo::has_career() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerInfo::set_has_career() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerInfo::clear_has_career() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerInfo::clear_career() {
  career_ = 0;
  clear_has_career();
}
inline ::google::protobuf::int32 PlayerInfo::career() const {
  return career_;
}
inline void PlayerInfo::set_career(::google::protobuf::int32 value) {
  set_has_career();
  career_ = value;
}

// optional int32 identity = 6;
inline bool PlayerInfo::has_identity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerInfo::set_has_identity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerInfo::clear_has_identity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerInfo::clear_identity() {
  identity_ = 0;
  clear_has_identity();
}
inline ::google::protobuf::int32 PlayerInfo::identity() const {
  return identity_;
}
inline void PlayerInfo::set_identity(::google::protobuf::int32 value) {
  set_has_identity();
  identity_ = value;
}

// optional int32 title = 7;
inline bool PlayerInfo::has_title() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayerInfo::set_has_title() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayerInfo::clear_has_title() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayerInfo::clear_title() {
  title_ = 0;
  clear_has_title();
}
inline ::google::protobuf::int32 PlayerInfo::title() const {
  return title_;
}
inline void PlayerInfo::set_title(::google::protobuf::int32 value) {
  set_has_title();
  title_ = value;
}

// optional int32 level = 8;
inline bool PlayerInfo::has_level() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlayerInfo::set_has_level() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlayerInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlayerInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 PlayerInfo::level() const {
  return level_;
}
inline void PlayerInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional uint64 exp = 9;
inline bool PlayerInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PlayerInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PlayerInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PlayerInfo::clear_exp() {
  exp_ = GOOGLE_ULONGLONG(0);
  clear_has_exp();
}
inline ::google::protobuf::uint64 PlayerInfo::exp() const {
  return exp_;
}
inline void PlayerInfo::set_exp(::google::protobuf::uint64 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 doubleexp = 10;
inline bool PlayerInfo::has_doubleexp() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PlayerInfo::set_has_doubleexp() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PlayerInfo::clear_has_doubleexp() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PlayerInfo::clear_doubleexp() {
  doubleexp_ = 0;
  clear_has_doubleexp();
}
inline ::google::protobuf::int32 PlayerInfo::doubleexp() const {
  return doubleexp_;
}
inline void PlayerInfo::set_doubleexp(::google::protobuf::int32 value) {
  set_has_doubleexp();
  doubleexp_ = value;
}

// optional int32 silver_pay = 11;
inline bool PlayerInfo::has_silver_pay() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PlayerInfo::set_has_silver_pay() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PlayerInfo::clear_has_silver_pay() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PlayerInfo::clear_silver_pay() {
  silver_pay_ = 0;
  clear_has_silver_pay();
}
inline ::google::protobuf::int32 PlayerInfo::silver_pay() const {
  return silver_pay_;
}
inline void PlayerInfo::set_silver_pay(::google::protobuf::int32 value) {
  set_has_silver_pay();
  silver_pay_ = value;
}

// optional int32 silver_free = 12;
inline bool PlayerInfo::has_silver_free() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PlayerInfo::set_has_silver_free() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PlayerInfo::clear_has_silver_free() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PlayerInfo::clear_silver_free() {
  silver_free_ = 0;
  clear_has_silver_free();
}
inline ::google::protobuf::int32 PlayerInfo::silver_free() const {
  return silver_free_;
}
inline void PlayerInfo::set_silver_free(::google::protobuf::int32 value) {
  set_has_silver_free();
  silver_free_ = value;
}

// optional int32 gold_pay = 13;
inline bool PlayerInfo::has_gold_pay() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PlayerInfo::set_has_gold_pay() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PlayerInfo::clear_has_gold_pay() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PlayerInfo::clear_gold_pay() {
  gold_pay_ = 0;
  clear_has_gold_pay();
}
inline ::google::protobuf::int32 PlayerInfo::gold_pay() const {
  return gold_pay_;
}
inline void PlayerInfo::set_gold_pay(::google::protobuf::int32 value) {
  set_has_gold_pay();
  gold_pay_ = value;
}

// optional int32 gold_free = 14;
inline bool PlayerInfo::has_gold_free() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PlayerInfo::set_has_gold_free() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PlayerInfo::clear_has_gold_free() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PlayerInfo::clear_gold_free() {
  gold_free_ = 0;
  clear_has_gold_free();
}
inline ::google::protobuf::int32 PlayerInfo::gold_free() const {
  return gold_free_;
}
inline void PlayerInfo::set_gold_free(::google::protobuf::int32 value) {
  set_has_gold_free();
  gold_free_ = value;
}

// optional int32 diamond_pay = 15;
inline bool PlayerInfo::has_diamond_pay() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PlayerInfo::set_has_diamond_pay() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PlayerInfo::clear_has_diamond_pay() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PlayerInfo::clear_diamond_pay() {
  diamond_pay_ = 0;
  clear_has_diamond_pay();
}
inline ::google::protobuf::int32 PlayerInfo::diamond_pay() const {
  return diamond_pay_;
}
inline void PlayerInfo::set_diamond_pay(::google::protobuf::int32 value) {
  set_has_diamond_pay();
  diamond_pay_ = value;
}

// optional int32 diamond_free = 16;
inline bool PlayerInfo::has_diamond_free() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PlayerInfo::set_has_diamond_free() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PlayerInfo::clear_has_diamond_free() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PlayerInfo::clear_diamond_free() {
  diamond_free_ = 0;
  clear_has_diamond_free();
}
inline ::google::protobuf::int32 PlayerInfo::diamond_free() const {
  return diamond_free_;
}
inline void PlayerInfo::set_diamond_free(::google::protobuf::int32 value) {
  set_has_diamond_free();
  diamond_free_ = value;
}

// optional uint32 timestamp = 17;
inline bool PlayerInfo::has_timestamp() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PlayerInfo::set_has_timestamp() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PlayerInfo::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PlayerInfo::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 PlayerInfo::timestamp() const {
  return timestamp_;
}
inline void PlayerInfo::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional uint32 platid = 18;
inline bool PlayerInfo::has_platid() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PlayerInfo::set_has_platid() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PlayerInfo::clear_has_platid() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PlayerInfo::clear_platid() {
  platid_ = 0u;
  clear_has_platid();
}
inline ::google::protobuf::uint32 PlayerInfo::platid() const {
  return platid_;
}
inline void PlayerInfo::set_platid(::google::protobuf::uint32 value) {
  set_has_platid();
  platid_ = value;
}

// optional string sdkuuid = 19;
inline bool PlayerInfo::has_sdkuuid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PlayerInfo::set_has_sdkuuid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PlayerInfo::clear_has_sdkuuid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PlayerInfo::clear_sdkuuid() {
  if (sdkuuid_ != &::google::protobuf::internal::kEmptyString) {
    sdkuuid_->clear();
  }
  clear_has_sdkuuid();
}
inline const ::std::string& PlayerInfo::sdkuuid() const {
  return *sdkuuid_;
}
inline void PlayerInfo::set_sdkuuid(const ::std::string& value) {
  set_has_sdkuuid();
  if (sdkuuid_ == &::google::protobuf::internal::kEmptyString) {
    sdkuuid_ = new ::std::string;
  }
  sdkuuid_->assign(value);
}
inline void PlayerInfo::set_sdkuuid(const char* value) {
  set_has_sdkuuid();
  if (sdkuuid_ == &::google::protobuf::internal::kEmptyString) {
    sdkuuid_ = new ::std::string;
  }
  sdkuuid_->assign(value);
}
inline void PlayerInfo::set_sdkuuid(const char* value, size_t size) {
  set_has_sdkuuid();
  if (sdkuuid_ == &::google::protobuf::internal::kEmptyString) {
    sdkuuid_ = new ::std::string;
  }
  sdkuuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerInfo::mutable_sdkuuid() {
  set_has_sdkuuid();
  if (sdkuuid_ == &::google::protobuf::internal::kEmptyString) {
    sdkuuid_ = new ::std::string;
  }
  return sdkuuid_;
}
inline ::std::string* PlayerInfo::release_sdkuuid() {
  clear_has_sdkuuid();
  if (sdkuuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdkuuid_;
    sdkuuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerInfo::set_allocated_sdkuuid(::std::string* sdkuuid) {
  if (sdkuuid_ != &::google::protobuf::internal::kEmptyString) {
    delete sdkuuid_;
  }
  if (sdkuuid) {
    set_has_sdkuuid();
    sdkuuid_ = sdkuuid;
  } else {
    clear_has_sdkuuid();
    sdkuuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .proto.message.DataInfo data_info = 20;
inline bool PlayerInfo::has_data_info() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PlayerInfo::set_has_data_info() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PlayerInfo::clear_has_data_info() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PlayerInfo::clear_data_info() {
  if (data_info_ != NULL) data_info_->::proto::message::DataInfo::Clear();
  clear_has_data_info();
}
inline const ::proto::message::DataInfo& PlayerInfo::data_info() const {
  return data_info_ != NULL ? *data_info_ : *default_instance_->data_info_;
}
inline ::proto::message::DataInfo* PlayerInfo::mutable_data_info() {
  set_has_data_info();
  if (data_info_ == NULL) data_info_ = new ::proto::message::DataInfo;
  return data_info_;
}
inline ::proto::message::DataInfo* PlayerInfo::release_data_info() {
  clear_has_data_info();
  ::proto::message::DataInfo* temp = data_info_;
  data_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_data_info(::proto::message::DataInfo* data_info) {
  delete data_info_;
  data_info_ = data_info;
  if (data_info) {
    set_has_data_info();
  } else {
    clear_has_data_info();
  }
}

// optional .proto.message.AllItemInfo item_info = 21;
inline bool PlayerInfo::has_item_info() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PlayerInfo::set_has_item_info() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PlayerInfo::clear_has_item_info() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PlayerInfo::clear_item_info() {
  if (item_info_ != NULL) item_info_->::proto::message::AllItemInfo::Clear();
  clear_has_item_info();
}
inline const ::proto::message::AllItemInfo& PlayerInfo::item_info() const {
  return item_info_ != NULL ? *item_info_ : *default_instance_->item_info_;
}
inline ::proto::message::AllItemInfo* PlayerInfo::mutable_item_info() {
  set_has_item_info();
  if (item_info_ == NULL) item_info_ = new ::proto::message::AllItemInfo;
  return item_info_;
}
inline ::proto::message::AllItemInfo* PlayerInfo::release_item_info() {
  clear_has_item_info();
  ::proto::message::AllItemInfo* temp = item_info_;
  item_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_item_info(::proto::message::AllItemInfo* item_info) {
  delete item_info_;
  item_info_ = item_info;
  if (item_info) {
    set_has_item_info();
  } else {
    clear_has_item_info();
  }
}

// optional .proto.message.EquiponInfo equipon_info = 22;
inline bool PlayerInfo::has_equipon_info() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PlayerInfo::set_has_equipon_info() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PlayerInfo::clear_has_equipon_info() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PlayerInfo::clear_equipon_info() {
  if (equipon_info_ != NULL) equipon_info_->::proto::message::EquiponInfo::Clear();
  clear_has_equipon_info();
}
inline const ::proto::message::EquiponInfo& PlayerInfo::equipon_info() const {
  return equipon_info_ != NULL ? *equipon_info_ : *default_instance_->equipon_info_;
}
inline ::proto::message::EquiponInfo* PlayerInfo::mutable_equipon_info() {
  set_has_equipon_info();
  if (equipon_info_ == NULL) equipon_info_ = new ::proto::message::EquiponInfo;
  return equipon_info_;
}
inline ::proto::message::EquiponInfo* PlayerInfo::release_equipon_info() {
  clear_has_equipon_info();
  ::proto::message::EquiponInfo* temp = equipon_info_;
  equipon_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_equipon_info(::proto::message::EquiponInfo* equipon_info) {
  delete equipon_info_;
  equipon_info_ = equipon_info;
  if (equipon_info) {
    set_has_equipon_info();
  } else {
    clear_has_equipon_info();
  }
}

// optional .proto.message.AllSkillInfo skill_info = 23;
inline bool PlayerInfo::has_skill_info() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PlayerInfo::set_has_skill_info() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PlayerInfo::clear_has_skill_info() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PlayerInfo::clear_skill_info() {
  if (skill_info_ != NULL) skill_info_->::proto::message::AllSkillInfo::Clear();
  clear_has_skill_info();
}
inline const ::proto::message::AllSkillInfo& PlayerInfo::skill_info() const {
  return skill_info_ != NULL ? *skill_info_ : *default_instance_->skill_info_;
}
inline ::proto::message::AllSkillInfo* PlayerInfo::mutable_skill_info() {
  set_has_skill_info();
  if (skill_info_ == NULL) skill_info_ = new ::proto::message::AllSkillInfo;
  return skill_info_;
}
inline ::proto::message::AllSkillInfo* PlayerInfo::release_skill_info() {
  clear_has_skill_info();
  ::proto::message::AllSkillInfo* temp = skill_info_;
  skill_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_skill_info(::proto::message::AllSkillInfo* skill_info) {
  delete skill_info_;
  skill_info_ = skill_info;
  if (skill_info) {
    set_has_skill_info();
  } else {
    clear_has_skill_info();
  }
}

// optional .proto.message.ProtoAllQuestInfo quest_info = 24;
inline bool PlayerInfo::has_quest_info() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PlayerInfo::set_has_quest_info() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PlayerInfo::clear_has_quest_info() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PlayerInfo::clear_quest_info() {
  if (quest_info_ != NULL) quest_info_->::proto::message::ProtoAllQuestInfo::Clear();
  clear_has_quest_info();
}
inline const ::proto::message::ProtoAllQuestInfo& PlayerInfo::quest_info() const {
  return quest_info_ != NULL ? *quest_info_ : *default_instance_->quest_info_;
}
inline ::proto::message::ProtoAllQuestInfo* PlayerInfo::mutable_quest_info() {
  set_has_quest_info();
  if (quest_info_ == NULL) quest_info_ = new ::proto::message::ProtoAllQuestInfo;
  return quest_info_;
}
inline ::proto::message::ProtoAllQuestInfo* PlayerInfo::release_quest_info() {
  clear_has_quest_info();
  ::proto::message::ProtoAllQuestInfo* temp = quest_info_;
  quest_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_quest_info(::proto::message::ProtoAllQuestInfo* quest_info) {
  delete quest_info_;
  quest_info_ = quest_info;
  if (quest_info) {
    set_has_quest_info();
  } else {
    clear_has_quest_info();
  }
}

// optional .proto.message.ShopInfo shop_info = 25;
inline bool PlayerInfo::has_shop_info() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PlayerInfo::set_has_shop_info() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PlayerInfo::clear_has_shop_info() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PlayerInfo::clear_shop_info() {
  if (shop_info_ != NULL) shop_info_->::proto::message::ShopInfo::Clear();
  clear_has_shop_info();
}
inline const ::proto::message::ShopInfo& PlayerInfo::shop_info() const {
  return shop_info_ != NULL ? *shop_info_ : *default_instance_->shop_info_;
}
inline ::proto::message::ShopInfo* PlayerInfo::mutable_shop_info() {
  set_has_shop_info();
  if (shop_info_ == NULL) shop_info_ = new ::proto::message::ShopInfo;
  return shop_info_;
}
inline ::proto::message::ShopInfo* PlayerInfo::release_shop_info() {
  clear_has_shop_info();
  ::proto::message::ShopInfo* temp = shop_info_;
  shop_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_shop_info(::proto::message::ShopInfo* shop_info) {
  delete shop_info_;
  shop_info_ = shop_info;
  if (shop_info) {
    set_has_shop_info();
  } else {
    clear_has_shop_info();
  }
}

// optional .proto.message.AllTalentInfo talent_info = 27;
inline bool PlayerInfo::has_talent_info() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PlayerInfo::set_has_talent_info() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PlayerInfo::clear_has_talent_info() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PlayerInfo::clear_talent_info() {
  if (talent_info_ != NULL) talent_info_->::proto::message::AllTalentInfo::Clear();
  clear_has_talent_info();
}
inline const ::proto::message::AllTalentInfo& PlayerInfo::talent_info() const {
  return talent_info_ != NULL ? *talent_info_ : *default_instance_->talent_info_;
}
inline ::proto::message::AllTalentInfo* PlayerInfo::mutable_talent_info() {
  set_has_talent_info();
  if (talent_info_ == NULL) talent_info_ = new ::proto::message::AllTalentInfo;
  return talent_info_;
}
inline ::proto::message::AllTalentInfo* PlayerInfo::release_talent_info() {
  clear_has_talent_info();
  ::proto::message::AllTalentInfo* temp = talent_info_;
  talent_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_talent_info(::proto::message::AllTalentInfo* talent_info) {
  delete talent_info_;
  talent_info_ = talent_info;
  if (talent_info) {
    set_has_talent_info();
  } else {
    clear_has_talent_info();
  }
}

// optional .proto.message.ProtoAllFriendInfo friend_info = 28;
inline bool PlayerInfo::has_friend_info() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PlayerInfo::set_has_friend_info() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PlayerInfo::clear_has_friend_info() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PlayerInfo::clear_friend_info() {
  if (friend_info_ != NULL) friend_info_->::proto::message::ProtoAllFriendInfo::Clear();
  clear_has_friend_info();
}
inline const ::proto::message::ProtoAllFriendInfo& PlayerInfo::friend_info() const {
  return friend_info_ != NULL ? *friend_info_ : *default_instance_->friend_info_;
}
inline ::proto::message::ProtoAllFriendInfo* PlayerInfo::mutable_friend_info() {
  set_has_friend_info();
  if (friend_info_ == NULL) friend_info_ = new ::proto::message::ProtoAllFriendInfo;
  return friend_info_;
}
inline ::proto::message::ProtoAllFriendInfo* PlayerInfo::release_friend_info() {
  clear_has_friend_info();
  ::proto::message::ProtoAllFriendInfo* temp = friend_info_;
  friend_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_friend_info(::proto::message::ProtoAllFriendInfo* friend_info) {
  delete friend_info_;
  friend_info_ = friend_info;
  if (friend_info) {
    set_has_friend_info();
  } else {
    clear_has_friend_info();
  }
}

// optional .proto.message.DungeonInfo dungeon_info = 29;
inline bool PlayerInfo::has_dungeon_info() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void PlayerInfo::set_has_dungeon_info() {
  _has_bits_[0] |= 0x08000000u;
}
inline void PlayerInfo::clear_has_dungeon_info() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void PlayerInfo::clear_dungeon_info() {
  if (dungeon_info_ != NULL) dungeon_info_->::proto::message::DungeonInfo::Clear();
  clear_has_dungeon_info();
}
inline const ::proto::message::DungeonInfo& PlayerInfo::dungeon_info() const {
  return dungeon_info_ != NULL ? *dungeon_info_ : *default_instance_->dungeon_info_;
}
inline ::proto::message::DungeonInfo* PlayerInfo::mutable_dungeon_info() {
  set_has_dungeon_info();
  if (dungeon_info_ == NULL) dungeon_info_ = new ::proto::message::DungeonInfo;
  return dungeon_info_;
}
inline ::proto::message::DungeonInfo* PlayerInfo::release_dungeon_info() {
  clear_has_dungeon_info();
  ::proto::message::DungeonInfo* temp = dungeon_info_;
  dungeon_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_dungeon_info(::proto::message::DungeonInfo* dungeon_info) {
  delete dungeon_info_;
  dungeon_info_ = dungeon_info;
  if (dungeon_info) {
    set_has_dungeon_info();
  } else {
    clear_has_dungeon_info();
  }
}

// optional .proto.message.ActivityInfo activity_info = 30;
inline bool PlayerInfo::has_activity_info() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void PlayerInfo::set_has_activity_info() {
  _has_bits_[0] |= 0x10000000u;
}
inline void PlayerInfo::clear_has_activity_info() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void PlayerInfo::clear_activity_info() {
  if (activity_info_ != NULL) activity_info_->::proto::message::ActivityInfo::Clear();
  clear_has_activity_info();
}
inline const ::proto::message::ActivityInfo& PlayerInfo::activity_info() const {
  return activity_info_ != NULL ? *activity_info_ : *default_instance_->activity_info_;
}
inline ::proto::message::ActivityInfo* PlayerInfo::mutable_activity_info() {
  set_has_activity_info();
  if (activity_info_ == NULL) activity_info_ = new ::proto::message::ActivityInfo;
  return activity_info_;
}
inline ::proto::message::ActivityInfo* PlayerInfo::release_activity_info() {
  clear_has_activity_info();
  ::proto::message::ActivityInfo* temp = activity_info_;
  activity_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_activity_info(::proto::message::ActivityInfo* activity_info) {
  delete activity_info_;
  activity_info_ = activity_info;
  if (activity_info) {
    set_has_activity_info();
  } else {
    clear_has_activity_info();
  }
}

// optional .proto.message.PlayerLivelyInfo lively_info = 31;
inline bool PlayerInfo::has_lively_info() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void PlayerInfo::set_has_lively_info() {
  _has_bits_[0] |= 0x20000000u;
}
inline void PlayerInfo::clear_has_lively_info() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void PlayerInfo::clear_lively_info() {
  if (lively_info_ != NULL) lively_info_->::proto::message::PlayerLivelyInfo::Clear();
  clear_has_lively_info();
}
inline const ::proto::message::PlayerLivelyInfo& PlayerInfo::lively_info() const {
  return lively_info_ != NULL ? *lively_info_ : *default_instance_->lively_info_;
}
inline ::proto::message::PlayerLivelyInfo* PlayerInfo::mutable_lively_info() {
  set_has_lively_info();
  if (lively_info_ == NULL) lively_info_ = new ::proto::message::PlayerLivelyInfo;
  return lively_info_;
}
inline ::proto::message::PlayerLivelyInfo* PlayerInfo::release_lively_info() {
  clear_has_lively_info();
  ::proto::message::PlayerLivelyInfo* temp = lively_info_;
  lively_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_lively_info(::proto::message::PlayerLivelyInfo* lively_info) {
  delete lively_info_;
  lively_info_ = lively_info;
  if (lively_info) {
    set_has_lively_info();
  } else {
    clear_has_lively_info();
  }
}

// optional .proto.message.TitleData title_info = 32;
inline bool PlayerInfo::has_title_info() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void PlayerInfo::set_has_title_info() {
  _has_bits_[0] |= 0x40000000u;
}
inline void PlayerInfo::clear_has_title_info() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void PlayerInfo::clear_title_info() {
  if (title_info_ != NULL) title_info_->::proto::message::TitleData::Clear();
  clear_has_title_info();
}
inline const ::proto::message::TitleData& PlayerInfo::title_info() const {
  return title_info_ != NULL ? *title_info_ : *default_instance_->title_info_;
}
inline ::proto::message::TitleData* PlayerInfo::mutable_title_info() {
  set_has_title_info();
  if (title_info_ == NULL) title_info_ = new ::proto::message::TitleData;
  return title_info_;
}
inline ::proto::message::TitleData* PlayerInfo::release_title_info() {
  clear_has_title_info();
  ::proto::message::TitleData* temp = title_info_;
  title_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_title_info(::proto::message::TitleData* title_info) {
  delete title_info_;
  title_info_ = title_info;
  if (title_info) {
    set_has_title_info();
  } else {
    clear_has_title_info();
  }
}

// optional .proto.message.WelfareInfo welfare_info = 33;
inline bool PlayerInfo::has_welfare_info() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void PlayerInfo::set_has_welfare_info() {
  _has_bits_[0] |= 0x80000000u;
}
inline void PlayerInfo::clear_has_welfare_info() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void PlayerInfo::clear_welfare_info() {
  if (welfare_info_ != NULL) welfare_info_->::proto::message::WelfareInfo::Clear();
  clear_has_welfare_info();
}
inline const ::proto::message::WelfareInfo& PlayerInfo::welfare_info() const {
  return welfare_info_ != NULL ? *welfare_info_ : *default_instance_->welfare_info_;
}
inline ::proto::message::WelfareInfo* PlayerInfo::mutable_welfare_info() {
  set_has_welfare_info();
  if (welfare_info_ == NULL) welfare_info_ = new ::proto::message::WelfareInfo;
  return welfare_info_;
}
inline ::proto::message::WelfareInfo* PlayerInfo::release_welfare_info() {
  clear_has_welfare_info();
  ::proto::message::WelfareInfo* temp = welfare_info_;
  welfare_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_welfare_info(::proto::message::WelfareInfo* welfare_info) {
  delete welfare_info_;
  welfare_info_ = welfare_info;
  if (welfare_info) {
    set_has_welfare_info();
  } else {
    clear_has_welfare_info();
  }
}

// optional .proto.message.DBAchieveInfo achieve_info = 34;
inline bool PlayerInfo::has_achieve_info() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void PlayerInfo::set_has_achieve_info() {
  _has_bits_[1] |= 0x00000001u;
}
inline void PlayerInfo::clear_has_achieve_info() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void PlayerInfo::clear_achieve_info() {
  if (achieve_info_ != NULL) achieve_info_->::proto::message::DBAchieveInfo::Clear();
  clear_has_achieve_info();
}
inline const ::proto::message::DBAchieveInfo& PlayerInfo::achieve_info() const {
  return achieve_info_ != NULL ? *achieve_info_ : *default_instance_->achieve_info_;
}
inline ::proto::message::DBAchieveInfo* PlayerInfo::mutable_achieve_info() {
  set_has_achieve_info();
  if (achieve_info_ == NULL) achieve_info_ = new ::proto::message::DBAchieveInfo;
  return achieve_info_;
}
inline ::proto::message::DBAchieveInfo* PlayerInfo::release_achieve_info() {
  clear_has_achieve_info();
  ::proto::message::DBAchieveInfo* temp = achieve_info_;
  achieve_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_achieve_info(::proto::message::DBAchieveInfo* achieve_info) {
  delete achieve_info_;
  achieve_info_ = achieve_info;
  if (achieve_info) {
    set_has_achieve_info();
  } else {
    clear_has_achieve_info();
  }
}

// optional .proto.message.ProtoGodWeaponAllCellInfo godweapon_info = 35;
inline bool PlayerInfo::has_godweapon_info() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void PlayerInfo::set_has_godweapon_info() {
  _has_bits_[1] |= 0x00000002u;
}
inline void PlayerInfo::clear_has_godweapon_info() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void PlayerInfo::clear_godweapon_info() {
  if (godweapon_info_ != NULL) godweapon_info_->::proto::message::ProtoGodWeaponAllCellInfo::Clear();
  clear_has_godweapon_info();
}
inline const ::proto::message::ProtoGodWeaponAllCellInfo& PlayerInfo::godweapon_info() const {
  return godweapon_info_ != NULL ? *godweapon_info_ : *default_instance_->godweapon_info_;
}
inline ::proto::message::ProtoGodWeaponAllCellInfo* PlayerInfo::mutable_godweapon_info() {
  set_has_godweapon_info();
  if (godweapon_info_ == NULL) godweapon_info_ = new ::proto::message::ProtoGodWeaponAllCellInfo;
  return godweapon_info_;
}
inline ::proto::message::ProtoGodWeaponAllCellInfo* PlayerInfo::release_godweapon_info() {
  clear_has_godweapon_info();
  ::proto::message::ProtoGodWeaponAllCellInfo* temp = godweapon_info_;
  godweapon_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_godweapon_info(::proto::message::ProtoGodWeaponAllCellInfo* godweapon_info) {
  delete godweapon_info_;
  godweapon_info_ = godweapon_info;
  if (godweapon_info) {
    set_has_godweapon_info();
  } else {
    clear_has_godweapon_info();
  }
}

// optional .proto.message.ProtoRideAllCellInfo ride_info = 36;
inline bool PlayerInfo::has_ride_info() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void PlayerInfo::set_has_ride_info() {
  _has_bits_[1] |= 0x00000004u;
}
inline void PlayerInfo::clear_has_ride_info() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void PlayerInfo::clear_ride_info() {
  if (ride_info_ != NULL) ride_info_->::proto::message::ProtoRideAllCellInfo::Clear();
  clear_has_ride_info();
}
inline const ::proto::message::ProtoRideAllCellInfo& PlayerInfo::ride_info() const {
  return ride_info_ != NULL ? *ride_info_ : *default_instance_->ride_info_;
}
inline ::proto::message::ProtoRideAllCellInfo* PlayerInfo::mutable_ride_info() {
  set_has_ride_info();
  if (ride_info_ == NULL) ride_info_ = new ::proto::message::ProtoRideAllCellInfo;
  return ride_info_;
}
inline ::proto::message::ProtoRideAllCellInfo* PlayerInfo::release_ride_info() {
  clear_has_ride_info();
  ::proto::message::ProtoRideAllCellInfo* temp = ride_info_;
  ride_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_ride_info(::proto::message::ProtoRideAllCellInfo* ride_info) {
  delete ride_info_;
  ride_info_ = ride_info;
  if (ride_info) {
    set_has_ride_info();
  } else {
    clear_has_ride_info();
  }
}

// optional .proto.message.ProtoPetAllCellInfo pet_info = 37;
inline bool PlayerInfo::has_pet_info() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void PlayerInfo::set_has_pet_info() {
  _has_bits_[1] |= 0x00000008u;
}
inline void PlayerInfo::clear_has_pet_info() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void PlayerInfo::clear_pet_info() {
  if (pet_info_ != NULL) pet_info_->::proto::message::ProtoPetAllCellInfo::Clear();
  clear_has_pet_info();
}
inline const ::proto::message::ProtoPetAllCellInfo& PlayerInfo::pet_info() const {
  return pet_info_ != NULL ? *pet_info_ : *default_instance_->pet_info_;
}
inline ::proto::message::ProtoPetAllCellInfo* PlayerInfo::mutable_pet_info() {
  set_has_pet_info();
  if (pet_info_ == NULL) pet_info_ = new ::proto::message::ProtoPetAllCellInfo;
  return pet_info_;
}
inline ::proto::message::ProtoPetAllCellInfo* PlayerInfo::release_pet_info() {
  clear_has_pet_info();
  ::proto::message::ProtoPetAllCellInfo* temp = pet_info_;
  pet_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_pet_info(::proto::message::ProtoPetAllCellInfo* pet_info) {
  delete pet_info_;
  pet_info_ = pet_info;
  if (pet_info) {
    set_has_pet_info();
  } else {
    clear_has_pet_info();
  }
}

// optional .proto.message.ProtoAwakenAllCellInfo awaken_info = 38;
inline bool PlayerInfo::has_awaken_info() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void PlayerInfo::set_has_awaken_info() {
  _has_bits_[1] |= 0x00000010u;
}
inline void PlayerInfo::clear_has_awaken_info() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void PlayerInfo::clear_awaken_info() {
  if (awaken_info_ != NULL) awaken_info_->::proto::message::ProtoAwakenAllCellInfo::Clear();
  clear_has_awaken_info();
}
inline const ::proto::message::ProtoAwakenAllCellInfo& PlayerInfo::awaken_info() const {
  return awaken_info_ != NULL ? *awaken_info_ : *default_instance_->awaken_info_;
}
inline ::proto::message::ProtoAwakenAllCellInfo* PlayerInfo::mutable_awaken_info() {
  set_has_awaken_info();
  if (awaken_info_ == NULL) awaken_info_ = new ::proto::message::ProtoAwakenAllCellInfo;
  return awaken_info_;
}
inline ::proto::message::ProtoAwakenAllCellInfo* PlayerInfo::release_awaken_info() {
  clear_has_awaken_info();
  ::proto::message::ProtoAwakenAllCellInfo* temp = awaken_info_;
  awaken_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_awaken_info(::proto::message::ProtoAwakenAllCellInfo* awaken_info) {
  delete awaken_info_;
  awaken_info_ = awaken_info;
  if (awaken_info) {
    set_has_awaken_info();
  } else {
    clear_has_awaken_info();
  }
}

// optional .proto.message.BoatAllData boat_info = 39;
inline bool PlayerInfo::has_boat_info() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void PlayerInfo::set_has_boat_info() {
  _has_bits_[1] |= 0x00000020u;
}
inline void PlayerInfo::clear_has_boat_info() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void PlayerInfo::clear_boat_info() {
  if (boat_info_ != NULL) boat_info_->::proto::message::BoatAllData::Clear();
  clear_has_boat_info();
}
inline const ::proto::message::BoatAllData& PlayerInfo::boat_info() const {
  return boat_info_ != NULL ? *boat_info_ : *default_instance_->boat_info_;
}
inline ::proto::message::BoatAllData* PlayerInfo::mutable_boat_info() {
  set_has_boat_info();
  if (boat_info_ == NULL) boat_info_ = new ::proto::message::BoatAllData;
  return boat_info_;
}
inline ::proto::message::BoatAllData* PlayerInfo::release_boat_info() {
  clear_has_boat_info();
  ::proto::message::BoatAllData* temp = boat_info_;
  boat_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_boat_info(::proto::message::BoatAllData* boat_info) {
  delete boat_info_;
  boat_info_ = boat_info;
  if (boat_info) {
    set_has_boat_info();
  } else {
    clear_has_boat_info();
  }
}

// optional .proto.message.ProtoMerAllCellInfo mercenary_info = 40;
inline bool PlayerInfo::has_mercenary_info() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void PlayerInfo::set_has_mercenary_info() {
  _has_bits_[1] |= 0x00000040u;
}
inline void PlayerInfo::clear_has_mercenary_info() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void PlayerInfo::clear_mercenary_info() {
  if (mercenary_info_ != NULL) mercenary_info_->::proto::message::ProtoMerAllCellInfo::Clear();
  clear_has_mercenary_info();
}
inline const ::proto::message::ProtoMerAllCellInfo& PlayerInfo::mercenary_info() const {
  return mercenary_info_ != NULL ? *mercenary_info_ : *default_instance_->mercenary_info_;
}
inline ::proto::message::ProtoMerAllCellInfo* PlayerInfo::mutable_mercenary_info() {
  set_has_mercenary_info();
  if (mercenary_info_ == NULL) mercenary_info_ = new ::proto::message::ProtoMerAllCellInfo;
  return mercenary_info_;
}
inline ::proto::message::ProtoMerAllCellInfo* PlayerInfo::release_mercenary_info() {
  clear_has_mercenary_info();
  ::proto::message::ProtoMerAllCellInfo* temp = mercenary_info_;
  mercenary_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_mercenary_info(::proto::message::ProtoMerAllCellInfo* mercenary_info) {
  delete mercenary_info_;
  mercenary_info_ = mercenary_info;
  if (mercenary_info) {
    set_has_mercenary_info();
  } else {
    clear_has_mercenary_info();
  }
}

// optional .proto.message.ProtoAllSevenDayTargetInfo sevenday_info = 41;
inline bool PlayerInfo::has_sevenday_info() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void PlayerInfo::set_has_sevenday_info() {
  _has_bits_[1] |= 0x00000080u;
}
inline void PlayerInfo::clear_has_sevenday_info() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void PlayerInfo::clear_sevenday_info() {
  if (sevenday_info_ != NULL) sevenday_info_->::proto::message::ProtoAllSevenDayTargetInfo::Clear();
  clear_has_sevenday_info();
}
inline const ::proto::message::ProtoAllSevenDayTargetInfo& PlayerInfo::sevenday_info() const {
  return sevenday_info_ != NULL ? *sevenday_info_ : *default_instance_->sevenday_info_;
}
inline ::proto::message::ProtoAllSevenDayTargetInfo* PlayerInfo::mutable_sevenday_info() {
  set_has_sevenday_info();
  if (sevenday_info_ == NULL) sevenday_info_ = new ::proto::message::ProtoAllSevenDayTargetInfo;
  return sevenday_info_;
}
inline ::proto::message::ProtoAllSevenDayTargetInfo* PlayerInfo::release_sevenday_info() {
  clear_has_sevenday_info();
  ::proto::message::ProtoAllSevenDayTargetInfo* temp = sevenday_info_;
  sevenday_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_sevenday_info(::proto::message::ProtoAllSevenDayTargetInfo* sevenday_info) {
  delete sevenday_info_;
  sevenday_info_ = sevenday_info;
  if (sevenday_info) {
    set_has_sevenday_info();
  } else {
    clear_has_sevenday_info();
  }
}

// optional .proto.message.Potential sPotential = 42;
inline bool PlayerInfo::has_spotential() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void PlayerInfo::set_has_spotential() {
  _has_bits_[1] |= 0x00000100u;
}
inline void PlayerInfo::clear_has_spotential() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void PlayerInfo::clear_spotential() {
  if (spotential_ != NULL) spotential_->::proto::message::Potential::Clear();
  clear_has_spotential();
}
inline const ::proto::message::Potential& PlayerInfo::spotential() const {
  return spotential_ != NULL ? *spotential_ : *default_instance_->spotential_;
}
inline ::proto::message::Potential* PlayerInfo::mutable_spotential() {
  set_has_spotential();
  if (spotential_ == NULL) spotential_ = new ::proto::message::Potential;
  return spotential_;
}
inline ::proto::message::Potential* PlayerInfo::release_spotential() {
  clear_has_spotential();
  ::proto::message::Potential* temp = spotential_;
  spotential_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_spotential(::proto::message::Potential* spotential) {
  delete spotential_;
  spotential_ = spotential;
  if (spotential) {
    set_has_spotential();
  } else {
    clear_has_spotential();
  }
}

// optional .proto.message.VIPInfo vip_info = 43;
inline bool PlayerInfo::has_vip_info() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void PlayerInfo::set_has_vip_info() {
  _has_bits_[1] |= 0x00000200u;
}
inline void PlayerInfo::clear_has_vip_info() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void PlayerInfo::clear_vip_info() {
  if (vip_info_ != NULL) vip_info_->::proto::message::VIPInfo::Clear();
  clear_has_vip_info();
}
inline const ::proto::message::VIPInfo& PlayerInfo::vip_info() const {
  return vip_info_ != NULL ? *vip_info_ : *default_instance_->vip_info_;
}
inline ::proto::message::VIPInfo* PlayerInfo::mutable_vip_info() {
  set_has_vip_info();
  if (vip_info_ == NULL) vip_info_ = new ::proto::message::VIPInfo;
  return vip_info_;
}
inline ::proto::message::VIPInfo* PlayerInfo::release_vip_info() {
  clear_has_vip_info();
  ::proto::message::VIPInfo* temp = vip_info_;
  vip_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_vip_info(::proto::message::VIPInfo* vip_info) {
  delete vip_info_;
  vip_info_ = vip_info;
  if (vip_info) {
    set_has_vip_info();
  } else {
    clear_has_vip_info();
  }
}

// optional .proto.message.ProtoAllProgressConInfo progresscon_info = 44;
inline bool PlayerInfo::has_progresscon_info() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void PlayerInfo::set_has_progresscon_info() {
  _has_bits_[1] |= 0x00000400u;
}
inline void PlayerInfo::clear_has_progresscon_info() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void PlayerInfo::clear_progresscon_info() {
  if (progresscon_info_ != NULL) progresscon_info_->::proto::message::ProtoAllProgressConInfo::Clear();
  clear_has_progresscon_info();
}
inline const ::proto::message::ProtoAllProgressConInfo& PlayerInfo::progresscon_info() const {
  return progresscon_info_ != NULL ? *progresscon_info_ : *default_instance_->progresscon_info_;
}
inline ::proto::message::ProtoAllProgressConInfo* PlayerInfo::mutable_progresscon_info() {
  set_has_progresscon_info();
  if (progresscon_info_ == NULL) progresscon_info_ = new ::proto::message::ProtoAllProgressConInfo;
  return progresscon_info_;
}
inline ::proto::message::ProtoAllProgressConInfo* PlayerInfo::release_progresscon_info() {
  clear_has_progresscon_info();
  ::proto::message::ProtoAllProgressConInfo* temp = progresscon_info_;
  progresscon_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_progresscon_info(::proto::message::ProtoAllProgressConInfo* progresscon_info) {
  delete progresscon_info_;
  progresscon_info_ = progresscon_info;
  if (progresscon_info) {
    set_has_progresscon_info();
  } else {
    clear_has_progresscon_info();
  }
}

// optional .proto.message.ProtoAllInvestmentInfo investment_info = 45;
inline bool PlayerInfo::has_investment_info() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void PlayerInfo::set_has_investment_info() {
  _has_bits_[1] |= 0x00000800u;
}
inline void PlayerInfo::clear_has_investment_info() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void PlayerInfo::clear_investment_info() {
  if (investment_info_ != NULL) investment_info_->::proto::message::ProtoAllInvestmentInfo::Clear();
  clear_has_investment_info();
}
inline const ::proto::message::ProtoAllInvestmentInfo& PlayerInfo::investment_info() const {
  return investment_info_ != NULL ? *investment_info_ : *default_instance_->investment_info_;
}
inline ::proto::message::ProtoAllInvestmentInfo* PlayerInfo::mutable_investment_info() {
  set_has_investment_info();
  if (investment_info_ == NULL) investment_info_ = new ::proto::message::ProtoAllInvestmentInfo;
  return investment_info_;
}
inline ::proto::message::ProtoAllInvestmentInfo* PlayerInfo::release_investment_info() {
  clear_has_investment_info();
  ::proto::message::ProtoAllInvestmentInfo* temp = investment_info_;
  investment_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_investment_info(::proto::message::ProtoAllInvestmentInfo* investment_info) {
  delete investment_info_;
  investment_info_ = investment_info;
  if (investment_info) {
    set_has_investment_info();
  } else {
    clear_has_investment_info();
  }
}

// optional .proto.message.ProtoAllDailyFirstChargeInfo dailycharge_info = 46;
inline bool PlayerInfo::has_dailycharge_info() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void PlayerInfo::set_has_dailycharge_info() {
  _has_bits_[1] |= 0x00001000u;
}
inline void PlayerInfo::clear_has_dailycharge_info() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void PlayerInfo::clear_dailycharge_info() {
  if (dailycharge_info_ != NULL) dailycharge_info_->::proto::message::ProtoAllDailyFirstChargeInfo::Clear();
  clear_has_dailycharge_info();
}
inline const ::proto::message::ProtoAllDailyFirstChargeInfo& PlayerInfo::dailycharge_info() const {
  return dailycharge_info_ != NULL ? *dailycharge_info_ : *default_instance_->dailycharge_info_;
}
inline ::proto::message::ProtoAllDailyFirstChargeInfo* PlayerInfo::mutable_dailycharge_info() {
  set_has_dailycharge_info();
  if (dailycharge_info_ == NULL) dailycharge_info_ = new ::proto::message::ProtoAllDailyFirstChargeInfo;
  return dailycharge_info_;
}
inline ::proto::message::ProtoAllDailyFirstChargeInfo* PlayerInfo::release_dailycharge_info() {
  clear_has_dailycharge_info();
  ::proto::message::ProtoAllDailyFirstChargeInfo* temp = dailycharge_info_;
  dailycharge_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_dailycharge_info(::proto::message::ProtoAllDailyFirstChargeInfo* dailycharge_info) {
  delete dailycharge_info_;
  dailycharge_info_ = dailycharge_info;
  if (dailycharge_info) {
    set_has_dailycharge_info();
  } else {
    clear_has_dailycharge_info();
  }
}

// optional .proto.message.ProtoAllLimitChargeInfo limitcharge_info = 47;
inline bool PlayerInfo::has_limitcharge_info() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void PlayerInfo::set_has_limitcharge_info() {
  _has_bits_[1] |= 0x00002000u;
}
inline void PlayerInfo::clear_has_limitcharge_info() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void PlayerInfo::clear_limitcharge_info() {
  if (limitcharge_info_ != NULL) limitcharge_info_->::proto::message::ProtoAllLimitChargeInfo::Clear();
  clear_has_limitcharge_info();
}
inline const ::proto::message::ProtoAllLimitChargeInfo& PlayerInfo::limitcharge_info() const {
  return limitcharge_info_ != NULL ? *limitcharge_info_ : *default_instance_->limitcharge_info_;
}
inline ::proto::message::ProtoAllLimitChargeInfo* PlayerInfo::mutable_limitcharge_info() {
  set_has_limitcharge_info();
  if (limitcharge_info_ == NULL) limitcharge_info_ = new ::proto::message::ProtoAllLimitChargeInfo;
  return limitcharge_info_;
}
inline ::proto::message::ProtoAllLimitChargeInfo* PlayerInfo::release_limitcharge_info() {
  clear_has_limitcharge_info();
  ::proto::message::ProtoAllLimitChargeInfo* temp = limitcharge_info_;
  limitcharge_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_limitcharge_info(::proto::message::ProtoAllLimitChargeInfo* limitcharge_info) {
  delete limitcharge_info_;
  limitcharge_info_ = limitcharge_info;
  if (limitcharge_info) {
    set_has_limitcharge_info();
  } else {
    clear_has_limitcharge_info();
  }
}

// optional .proto.message.ProtoAllChargeBigGiftInfo chargebiggift_info = 48;
inline bool PlayerInfo::has_chargebiggift_info() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void PlayerInfo::set_has_chargebiggift_info() {
  _has_bits_[1] |= 0x00004000u;
}
inline void PlayerInfo::clear_has_chargebiggift_info() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void PlayerInfo::clear_chargebiggift_info() {
  if (chargebiggift_info_ != NULL) chargebiggift_info_->::proto::message::ProtoAllChargeBigGiftInfo::Clear();
  clear_has_chargebiggift_info();
}
inline const ::proto::message::ProtoAllChargeBigGiftInfo& PlayerInfo::chargebiggift_info() const {
  return chargebiggift_info_ != NULL ? *chargebiggift_info_ : *default_instance_->chargebiggift_info_;
}
inline ::proto::message::ProtoAllChargeBigGiftInfo* PlayerInfo::mutable_chargebiggift_info() {
  set_has_chargebiggift_info();
  if (chargebiggift_info_ == NULL) chargebiggift_info_ = new ::proto::message::ProtoAllChargeBigGiftInfo;
  return chargebiggift_info_;
}
inline ::proto::message::ProtoAllChargeBigGiftInfo* PlayerInfo::release_chargebiggift_info() {
  clear_has_chargebiggift_info();
  ::proto::message::ProtoAllChargeBigGiftInfo* temp = chargebiggift_info_;
  chargebiggift_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_chargebiggift_info(::proto::message::ProtoAllChargeBigGiftInfo* chargebiggift_info) {
  delete chargebiggift_info_;
  chargebiggift_info_ = chargebiggift_info;
  if (chargebiggift_info) {
    set_has_chargebiggift_info();
  } else {
    clear_has_chargebiggift_info();
  }
}

// optional .proto.message.ContinuousChargeInfo continuouscharge_info = 49;
inline bool PlayerInfo::has_continuouscharge_info() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void PlayerInfo::set_has_continuouscharge_info() {
  _has_bits_[1] |= 0x00008000u;
}
inline void PlayerInfo::clear_has_continuouscharge_info() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void PlayerInfo::clear_continuouscharge_info() {
  if (continuouscharge_info_ != NULL) continuouscharge_info_->::proto::message::ContinuousChargeInfo::Clear();
  clear_has_continuouscharge_info();
}
inline const ::proto::message::ContinuousChargeInfo& PlayerInfo::continuouscharge_info() const {
  return continuouscharge_info_ != NULL ? *continuouscharge_info_ : *default_instance_->continuouscharge_info_;
}
inline ::proto::message::ContinuousChargeInfo* PlayerInfo::mutable_continuouscharge_info() {
  set_has_continuouscharge_info();
  if (continuouscharge_info_ == NULL) continuouscharge_info_ = new ::proto::message::ContinuousChargeInfo;
  return continuouscharge_info_;
}
inline ::proto::message::ContinuousChargeInfo* PlayerInfo::release_continuouscharge_info() {
  clear_has_continuouscharge_info();
  ::proto::message::ContinuousChargeInfo* temp = continuouscharge_info_;
  continuouscharge_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_continuouscharge_info(::proto::message::ContinuousChargeInfo* continuouscharge_info) {
  delete continuouscharge_info_;
  continuouscharge_info_ = continuouscharge_info;
  if (continuouscharge_info) {
    set_has_continuouscharge_info();
  } else {
    clear_has_continuouscharge_info();
  }
}

// optional .proto.message.SpecialSaleInfo specialsale_info = 50;
inline bool PlayerInfo::has_specialsale_info() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void PlayerInfo::set_has_specialsale_info() {
  _has_bits_[1] |= 0x00010000u;
}
inline void PlayerInfo::clear_has_specialsale_info() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void PlayerInfo::clear_specialsale_info() {
  if (specialsale_info_ != NULL) specialsale_info_->::proto::message::SpecialSaleInfo::Clear();
  clear_has_specialsale_info();
}
inline const ::proto::message::SpecialSaleInfo& PlayerInfo::specialsale_info() const {
  return specialsale_info_ != NULL ? *specialsale_info_ : *default_instance_->specialsale_info_;
}
inline ::proto::message::SpecialSaleInfo* PlayerInfo::mutable_specialsale_info() {
  set_has_specialsale_info();
  if (specialsale_info_ == NULL) specialsale_info_ = new ::proto::message::SpecialSaleInfo;
  return specialsale_info_;
}
inline ::proto::message::SpecialSaleInfo* PlayerInfo::release_specialsale_info() {
  clear_has_specialsale_info();
  ::proto::message::SpecialSaleInfo* temp = specialsale_info_;
  specialsale_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_specialsale_info(::proto::message::SpecialSaleInfo* specialsale_info) {
  delete specialsale_info_;
  specialsale_info_ = specialsale_info;
  if (specialsale_info) {
    set_has_specialsale_info();
  } else {
    clear_has_specialsale_info();
  }
}

// optional .proto.message.LostTreasureInfo losttreasure_info = 51;
inline bool PlayerInfo::has_losttreasure_info() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void PlayerInfo::set_has_losttreasure_info() {
  _has_bits_[1] |= 0x00020000u;
}
inline void PlayerInfo::clear_has_losttreasure_info() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void PlayerInfo::clear_losttreasure_info() {
  if (losttreasure_info_ != NULL) losttreasure_info_->::proto::message::LostTreasureInfo::Clear();
  clear_has_losttreasure_info();
}
inline const ::proto::message::LostTreasureInfo& PlayerInfo::losttreasure_info() const {
  return losttreasure_info_ != NULL ? *losttreasure_info_ : *default_instance_->losttreasure_info_;
}
inline ::proto::message::LostTreasureInfo* PlayerInfo::mutable_losttreasure_info() {
  set_has_losttreasure_info();
  if (losttreasure_info_ == NULL) losttreasure_info_ = new ::proto::message::LostTreasureInfo;
  return losttreasure_info_;
}
inline ::proto::message::LostTreasureInfo* PlayerInfo::release_losttreasure_info() {
  clear_has_losttreasure_info();
  ::proto::message::LostTreasureInfo* temp = losttreasure_info_;
  losttreasure_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_losttreasure_info(::proto::message::LostTreasureInfo* losttreasure_info) {
  delete losttreasure_info_;
  losttreasure_info_ = losttreasure_info;
  if (losttreasure_info) {
    set_has_losttreasure_info();
  } else {
    clear_has_losttreasure_info();
  }
}

// optional .proto.message.MoneyTreeInfo moneytree_info = 52;
inline bool PlayerInfo::has_moneytree_info() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void PlayerInfo::set_has_moneytree_info() {
  _has_bits_[1] |= 0x00040000u;
}
inline void PlayerInfo::clear_has_moneytree_info() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void PlayerInfo::clear_moneytree_info() {
  if (moneytree_info_ != NULL) moneytree_info_->::proto::message::MoneyTreeInfo::Clear();
  clear_has_moneytree_info();
}
inline const ::proto::message::MoneyTreeInfo& PlayerInfo::moneytree_info() const {
  return moneytree_info_ != NULL ? *moneytree_info_ : *default_instance_->moneytree_info_;
}
inline ::proto::message::MoneyTreeInfo* PlayerInfo::mutable_moneytree_info() {
  set_has_moneytree_info();
  if (moneytree_info_ == NULL) moneytree_info_ = new ::proto::message::MoneyTreeInfo;
  return moneytree_info_;
}
inline ::proto::message::MoneyTreeInfo* PlayerInfo::release_moneytree_info() {
  clear_has_moneytree_info();
  ::proto::message::MoneyTreeInfo* temp = moneytree_info_;
  moneytree_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_moneytree_info(::proto::message::MoneyTreeInfo* moneytree_info) {
  delete moneytree_info_;
  moneytree_info_ = moneytree_info;
  if (moneytree_info) {
    set_has_moneytree_info();
  } else {
    clear_has_moneytree_info();
  }
}

// optional .proto.message.DiscountStoreInfo discountstore_info = 53;
inline bool PlayerInfo::has_discountstore_info() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void PlayerInfo::set_has_discountstore_info() {
  _has_bits_[1] |= 0x00080000u;
}
inline void PlayerInfo::clear_has_discountstore_info() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void PlayerInfo::clear_discountstore_info() {
  if (discountstore_info_ != NULL) discountstore_info_->::proto::message::DiscountStoreInfo::Clear();
  clear_has_discountstore_info();
}
inline const ::proto::message::DiscountStoreInfo& PlayerInfo::discountstore_info() const {
  return discountstore_info_ != NULL ? *discountstore_info_ : *default_instance_->discountstore_info_;
}
inline ::proto::message::DiscountStoreInfo* PlayerInfo::mutable_discountstore_info() {
  set_has_discountstore_info();
  if (discountstore_info_ == NULL) discountstore_info_ = new ::proto::message::DiscountStoreInfo;
  return discountstore_info_;
}
inline ::proto::message::DiscountStoreInfo* PlayerInfo::release_discountstore_info() {
  clear_has_discountstore_info();
  ::proto::message::DiscountStoreInfo* temp = discountstore_info_;
  discountstore_info_ = NULL;
  return temp;
}
inline void PlayerInfo::set_allocated_discountstore_info(::proto::message::DiscountStoreInfo* discountstore_info) {
  delete discountstore_info_;
  discountstore_info_ = discountstore_info;
  if (discountstore_info) {
    set_has_discountstore_info();
  } else {
    clear_has_discountstore_info();
  }
}

// -------------------------------------------------------------------

// CreatePlayer

// optional uint64 charid = 1;
inline bool CreatePlayer::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreatePlayer::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreatePlayer::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreatePlayer::clear_charid() {
  charid_ = GOOGLE_ULONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::uint64 CreatePlayer::charid() const {
  return charid_;
}
inline void CreatePlayer::set_charid(::google::protobuf::uint64 value) {
  set_has_charid();
  charid_ = value;
}

// optional string account = 2;
inline bool CreatePlayer::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreatePlayer::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreatePlayer::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreatePlayer::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& CreatePlayer::account() const {
  return *account_;
}
inline void CreatePlayer::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CreatePlayer::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CreatePlayer::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreatePlayer::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* CreatePlayer::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreatePlayer::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string charname = 3;
inline bool CreatePlayer::has_charname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreatePlayer::set_has_charname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreatePlayer::clear_has_charname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreatePlayer::clear_charname() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    charname_->clear();
  }
  clear_has_charname();
}
inline const ::std::string& CreatePlayer::charname() const {
  return *charname_;
}
inline void CreatePlayer::set_charname(const ::std::string& value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void CreatePlayer::set_charname(const char* value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void CreatePlayer::set_charname(const char* value, size_t size) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreatePlayer::mutable_charname() {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  return charname_;
}
inline ::std::string* CreatePlayer::release_charname() {
  clear_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charname_;
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreatePlayer::set_allocated_charname(::std::string* charname) {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  if (charname) {
    set_has_charname();
    charname_ = charname;
  } else {
    clear_has_charname();
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 server_id = 4;
inline bool CreatePlayer::has_server_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreatePlayer::set_has_server_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreatePlayer::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreatePlayer::clear_server_id() {
  server_id_ = 0;
  clear_has_server_id();
}
inline ::google::protobuf::int32 CreatePlayer::server_id() const {
  return server_id_;
}
inline void CreatePlayer::set_server_id(::google::protobuf::int32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional int32 sex = 5;
inline bool CreatePlayer::has_sex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreatePlayer::set_has_sex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreatePlayer::clear_has_sex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreatePlayer::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 CreatePlayer::sex() const {
  return sex_;
}
inline void CreatePlayer::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional int32 career = 6;
inline bool CreatePlayer::has_career() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreatePlayer::set_has_career() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreatePlayer::clear_has_career() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreatePlayer::clear_career() {
  career_ = 0;
  clear_has_career();
}
inline ::google::protobuf::int32 CreatePlayer::career() const {
  return career_;
}
inline void CreatePlayer::set_career(::google::protobuf::int32 value) {
  set_has_career();
  career_ = value;
}

// optional int32 plat_id = 7;
inline bool CreatePlayer::has_plat_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CreatePlayer::set_has_plat_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CreatePlayer::clear_has_plat_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CreatePlayer::clear_plat_id() {
  plat_id_ = 0;
  clear_has_plat_id();
}
inline ::google::protobuf::int32 CreatePlayer::plat_id() const {
  return plat_id_;
}
inline void CreatePlayer::set_plat_id(::google::protobuf::int32 value) {
  set_has_plat_id();
  plat_id_ = value;
}

// optional string sdk_uuid = 8;
inline bool CreatePlayer::has_sdk_uuid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CreatePlayer::set_has_sdk_uuid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CreatePlayer::clear_has_sdk_uuid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CreatePlayer::clear_sdk_uuid() {
  if (sdk_uuid_ != &::google::protobuf::internal::kEmptyString) {
    sdk_uuid_->clear();
  }
  clear_has_sdk_uuid();
}
inline const ::std::string& CreatePlayer::sdk_uuid() const {
  return *sdk_uuid_;
}
inline void CreatePlayer::set_sdk_uuid(const ::std::string& value) {
  set_has_sdk_uuid();
  if (sdk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    sdk_uuid_ = new ::std::string;
  }
  sdk_uuid_->assign(value);
}
inline void CreatePlayer::set_sdk_uuid(const char* value) {
  set_has_sdk_uuid();
  if (sdk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    sdk_uuid_ = new ::std::string;
  }
  sdk_uuid_->assign(value);
}
inline void CreatePlayer::set_sdk_uuid(const char* value, size_t size) {
  set_has_sdk_uuid();
  if (sdk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    sdk_uuid_ = new ::std::string;
  }
  sdk_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreatePlayer::mutable_sdk_uuid() {
  set_has_sdk_uuid();
  if (sdk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    sdk_uuid_ = new ::std::string;
  }
  return sdk_uuid_;
}
inline ::std::string* CreatePlayer::release_sdk_uuid() {
  clear_has_sdk_uuid();
  if (sdk_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdk_uuid_;
    sdk_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreatePlayer::set_allocated_sdk_uuid(::std::string* sdk_uuid) {
  if (sdk_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete sdk_uuid_;
  }
  if (sdk_uuid) {
    set_has_sdk_uuid();
    sdk_uuid_ = sdk_uuid;
  } else {
    clear_has_sdk_uuid();
    sdk_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PlayerRank

// optional uint64 charid = 1;
inline bool PlayerRank::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerRank::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerRank::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerRank::clear_charid() {
  charid_ = GOOGLE_ULONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::uint64 PlayerRank::charid() const {
  return charid_;
}
inline void PlayerRank::set_charid(::google::protobuf::uint64 value) {
  set_has_charid();
  charid_ = value;
}

// optional string charname = 2;
inline bool PlayerRank::has_charname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerRank::set_has_charname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerRank::clear_has_charname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerRank::clear_charname() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    charname_->clear();
  }
  clear_has_charname();
}
inline const ::std::string& PlayerRank::charname() const {
  return *charname_;
}
inline void PlayerRank::set_charname(const ::std::string& value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void PlayerRank::set_charname(const char* value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void PlayerRank::set_charname(const char* value, size_t size) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerRank::mutable_charname() {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  return charname_;
}
inline ::std::string* PlayerRank::release_charname() {
  clear_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charname_;
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerRank::set_allocated_charname(::std::string* charname) {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  if (charname) {
    set_has_charname();
    charname_ = charname;
  } else {
    clear_has_charname();
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 career = 3;
inline bool PlayerRank::has_career() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerRank::set_has_career() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerRank::clear_has_career() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerRank::clear_career() {
  career_ = 0;
  clear_has_career();
}
inline ::google::protobuf::int32 PlayerRank::career() const {
  return career_;
}
inline void PlayerRank::set_career(::google::protobuf::int32 value) {
  set_has_career();
  career_ = value;
}

// optional int32 level = 4;
inline bool PlayerRank::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayerRank::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayerRank::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayerRank::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 PlayerRank::level() const {
  return level_;
}
inline void PlayerRank::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 pvp_score = 5;
inline bool PlayerRank::has_pvp_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlayerRank::set_has_pvp_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlayerRank::clear_has_pvp_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlayerRank::clear_pvp_score() {
  pvp_score_ = 0;
  clear_has_pvp_score();
}
inline ::google::protobuf::int32 PlayerRank::pvp_score() const {
  return pvp_score_;
}
inline void PlayerRank::set_pvp_score(::google::protobuf::int32 value) {
  set_has_pvp_score();
  pvp_score_ = value;
}

// optional int32 pvp_num = 6;
inline bool PlayerRank::has_pvp_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlayerRank::set_has_pvp_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlayerRank::clear_has_pvp_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlayerRank::clear_pvp_num() {
  pvp_num_ = 0;
  clear_has_pvp_num();
}
inline ::google::protobuf::int32 PlayerRank::pvp_num() const {
  return pvp_num_;
}
inline void PlayerRank::set_pvp_num(::google::protobuf::int32 value) {
  set_has_pvp_num();
  pvp_num_ = value;
}

// optional .proto.message.PVPInfo pvp_info = 7;
inline bool PlayerRank::has_pvp_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlayerRank::set_has_pvp_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlayerRank::clear_has_pvp_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlayerRank::clear_pvp_info() {
  if (pvp_info_ != NULL) pvp_info_->::proto::message::PVPInfo::Clear();
  clear_has_pvp_info();
}
inline const ::proto::message::PVPInfo& PlayerRank::pvp_info() const {
  return pvp_info_ != NULL ? *pvp_info_ : *default_instance_->pvp_info_;
}
inline ::proto::message::PVPInfo* PlayerRank::mutable_pvp_info() {
  set_has_pvp_info();
  if (pvp_info_ == NULL) pvp_info_ = new ::proto::message::PVPInfo;
  return pvp_info_;
}
inline ::proto::message::PVPInfo* PlayerRank::release_pvp_info() {
  clear_has_pvp_info();
  ::proto::message::PVPInfo* temp = pvp_info_;
  pvp_info_ = NULL;
  return temp;
}
inline void PlayerRank::set_allocated_pvp_info(::proto::message::PVPInfo* pvp_info) {
  delete pvp_info_;
  pvp_info_ = pvp_info;
  if (pvp_info) {
    set_has_pvp_info();
  } else {
    clear_has_pvp_info();
  }
}

// optional int32 arena_score = 8;
inline bool PlayerRank::has_arena_score() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlayerRank::set_has_arena_score() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlayerRank::clear_has_arena_score() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlayerRank::clear_arena_score() {
  arena_score_ = 0;
  clear_has_arena_score();
}
inline ::google::protobuf::int32 PlayerRank::arena_score() const {
  return arena_score_;
}
inline void PlayerRank::set_arena_score(::google::protobuf::int32 value) {
  set_has_arena_score();
  arena_score_ = value;
}

// optional int32 arena_stage = 9;
inline bool PlayerRank::has_arena_stage() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PlayerRank::set_has_arena_stage() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PlayerRank::clear_has_arena_stage() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PlayerRank::clear_arena_stage() {
  arena_stage_ = 0;
  clear_has_arena_stage();
}
inline ::google::protobuf::int32 PlayerRank::arena_stage() const {
  return arena_stage_;
}
inline void PlayerRank::set_arena_stage(::google::protobuf::int32 value) {
  set_has_arena_stage();
  arena_stage_ = value;
}

// optional .proto.message.ArenaInfo arena_info = 10;
inline bool PlayerRank::has_arena_info() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PlayerRank::set_has_arena_info() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PlayerRank::clear_has_arena_info() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PlayerRank::clear_arena_info() {
  if (arena_info_ != NULL) arena_info_->::proto::message::ArenaInfo::Clear();
  clear_has_arena_info();
}
inline const ::proto::message::ArenaInfo& PlayerRank::arena_info() const {
  return arena_info_ != NULL ? *arena_info_ : *default_instance_->arena_info_;
}
inline ::proto::message::ArenaInfo* PlayerRank::mutable_arena_info() {
  set_has_arena_info();
  if (arena_info_ == NULL) arena_info_ = new ::proto::message::ArenaInfo;
  return arena_info_;
}
inline ::proto::message::ArenaInfo* PlayerRank::release_arena_info() {
  clear_has_arena_info();
  ::proto::message::ArenaInfo* temp = arena_info_;
  arena_info_ = NULL;
  return temp;
}
inline void PlayerRank::set_allocated_arena_info(::proto::message::ArenaInfo* arena_info) {
  delete arena_info_;
  arena_info_ = arena_info;
  if (arena_info) {
    set_has_arena_info();
  } else {
    clear_has_arena_info();
  }
}

// optional int32 boat_pvp_score = 11;
inline bool PlayerRank::has_boat_pvp_score() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PlayerRank::set_has_boat_pvp_score() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PlayerRank::clear_has_boat_pvp_score() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PlayerRank::clear_boat_pvp_score() {
  boat_pvp_score_ = 0;
  clear_has_boat_pvp_score();
}
inline ::google::protobuf::int32 PlayerRank::boat_pvp_score() const {
  return boat_pvp_score_;
}
inline void PlayerRank::set_boat_pvp_score(::google::protobuf::int32 value) {
  set_has_boat_pvp_score();
  boat_pvp_score_ = value;
}

// optional int32 boat_pvp_num = 12;
inline bool PlayerRank::has_boat_pvp_num() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PlayerRank::set_has_boat_pvp_num() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PlayerRank::clear_has_boat_pvp_num() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PlayerRank::clear_boat_pvp_num() {
  boat_pvp_num_ = 0;
  clear_has_boat_pvp_num();
}
inline ::google::protobuf::int32 PlayerRank::boat_pvp_num() const {
  return boat_pvp_num_;
}
inline void PlayerRank::set_boat_pvp_num(::google::protobuf::int32 value) {
  set_has_boat_pvp_num();
  boat_pvp_num_ = value;
}

// optional .proto.message.PVPInfo boat_pvp_info = 13;
inline bool PlayerRank::has_boat_pvp_info() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PlayerRank::set_has_boat_pvp_info() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PlayerRank::clear_has_boat_pvp_info() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PlayerRank::clear_boat_pvp_info() {
  if (boat_pvp_info_ != NULL) boat_pvp_info_->::proto::message::PVPInfo::Clear();
  clear_has_boat_pvp_info();
}
inline const ::proto::message::PVPInfo& PlayerRank::boat_pvp_info() const {
  return boat_pvp_info_ != NULL ? *boat_pvp_info_ : *default_instance_->boat_pvp_info_;
}
inline ::proto::message::PVPInfo* PlayerRank::mutable_boat_pvp_info() {
  set_has_boat_pvp_info();
  if (boat_pvp_info_ == NULL) boat_pvp_info_ = new ::proto::message::PVPInfo;
  return boat_pvp_info_;
}
inline ::proto::message::PVPInfo* PlayerRank::release_boat_pvp_info() {
  clear_has_boat_pvp_info();
  ::proto::message::PVPInfo* temp = boat_pvp_info_;
  boat_pvp_info_ = NULL;
  return temp;
}
inline void PlayerRank::set_allocated_boat_pvp_info(::proto::message::PVPInfo* boat_pvp_info) {
  delete boat_pvp_info_;
  boat_pvp_info_ = boat_pvp_info;
  if (boat_pvp_info) {
    set_has_boat_pvp_info();
  } else {
    clear_has_boat_pvp_info();
  }
}

// -------------------------------------------------------------------

// NameMsg

// optional uint64 charid = 1;
inline bool NameMsg::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameMsg::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameMsg::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameMsg::clear_charid() {
  charid_ = GOOGLE_ULONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::uint64 NameMsg::charid() const {
  return charid_;
}
inline void NameMsg::set_charid(::google::protobuf::uint64 value) {
  set_has_charid();
  charid_ = value;
}

// optional string charname = 2;
inline bool NameMsg::has_charname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameMsg::set_has_charname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameMsg::clear_has_charname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameMsg::clear_charname() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    charname_->clear();
  }
  clear_has_charname();
}
inline const ::std::string& NameMsg::charname() const {
  return *charname_;
}
inline void NameMsg::set_charname(const ::std::string& value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void NameMsg::set_charname(const char* value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void NameMsg::set_charname(const char* value, size_t size) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NameMsg::mutable_charname() {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  return charname_;
}
inline ::std::string* NameMsg::release_charname() {
  clear_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charname_;
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NameMsg::set_allocated_charname(::std::string* charname) {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  if (charname) {
    set_has_charname();
    charname_ = charname;
  } else {
    clear_has_charname();
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DBOfflineEvent

// optional uint32 eventid = 1;
inline bool DBOfflineEvent::has_eventid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBOfflineEvent::set_has_eventid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBOfflineEvent::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBOfflineEvent::clear_eventid() {
  eventid_ = 0u;
  clear_has_eventid();
}
inline ::google::protobuf::uint32 DBOfflineEvent::eventid() const {
  return eventid_;
}
inline void DBOfflineEvent::set_eventid(::google::protobuf::uint32 value) {
  set_has_eventid();
  eventid_ = value;
}

// optional int32 eventtype = 2;
inline bool DBOfflineEvent::has_eventtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBOfflineEvent::set_has_eventtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBOfflineEvent::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBOfflineEvent::clear_eventtype() {
  eventtype_ = 0;
  clear_has_eventtype();
}
inline ::google::protobuf::int32 DBOfflineEvent::eventtype() const {
  return eventtype_;
}
inline void DBOfflineEvent::set_eventtype(::google::protobuf::int32 value) {
  set_has_eventtype();
  eventtype_ = value;
}

// optional uint64 fromply = 3;
inline bool DBOfflineEvent::has_fromply() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DBOfflineEvent::set_has_fromply() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DBOfflineEvent::clear_has_fromply() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DBOfflineEvent::clear_fromply() {
  fromply_ = GOOGLE_ULONGLONG(0);
  clear_has_fromply();
}
inline ::google::protobuf::uint64 DBOfflineEvent::fromply() const {
  return fromply_;
}
inline void DBOfflineEvent::set_fromply(::google::protobuf::uint64 value) {
  set_has_fromply();
  fromply_ = value;
}

// optional uint64 toply = 4;
inline bool DBOfflineEvent::has_toply() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DBOfflineEvent::set_has_toply() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DBOfflineEvent::clear_has_toply() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DBOfflineEvent::clear_toply() {
  toply_ = GOOGLE_ULONGLONG(0);
  clear_has_toply();
}
inline ::google::protobuf::uint64 DBOfflineEvent::toply() const {
  return toply_;
}
inline void DBOfflineEvent::set_toply(::google::protobuf::uint64 value) {
  set_has_toply();
  toply_ = value;
}

// optional int32 eventstate = 5;
inline bool DBOfflineEvent::has_eventstate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DBOfflineEvent::set_has_eventstate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DBOfflineEvent::clear_has_eventstate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DBOfflineEvent::clear_eventstate() {
  eventstate_ = 0;
  clear_has_eventstate();
}
inline ::google::protobuf::int32 DBOfflineEvent::eventstate() const {
  return eventstate_;
}
inline void DBOfflineEvent::set_eventstate(::google::protobuf::int32 value) {
  set_has_eventstate();
  eventstate_ = value;
}

// optional int32 intparam1 = 6;
inline bool DBOfflineEvent::has_intparam1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DBOfflineEvent::set_has_intparam1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DBOfflineEvent::clear_has_intparam1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DBOfflineEvent::clear_intparam1() {
  intparam1_ = 0;
  clear_has_intparam1();
}
inline ::google::protobuf::int32 DBOfflineEvent::intparam1() const {
  return intparam1_;
}
inline void DBOfflineEvent::set_intparam1(::google::protobuf::int32 value) {
  set_has_intparam1();
  intparam1_ = value;
}

// optional int32 intparam2 = 7;
inline bool DBOfflineEvent::has_intparam2() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DBOfflineEvent::set_has_intparam2() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DBOfflineEvent::clear_has_intparam2() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DBOfflineEvent::clear_intparam2() {
  intparam2_ = 0;
  clear_has_intparam2();
}
inline ::google::protobuf::int32 DBOfflineEvent::intparam2() const {
  return intparam2_;
}
inline void DBOfflineEvent::set_intparam2(::google::protobuf::int32 value) {
  set_has_intparam2();
  intparam2_ = value;
}

// optional string strparam1 = 8;
inline bool DBOfflineEvent::has_strparam1() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DBOfflineEvent::set_has_strparam1() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DBOfflineEvent::clear_has_strparam1() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DBOfflineEvent::clear_strparam1() {
  if (strparam1_ != &::google::protobuf::internal::kEmptyString) {
    strparam1_->clear();
  }
  clear_has_strparam1();
}
inline const ::std::string& DBOfflineEvent::strparam1() const {
  return *strparam1_;
}
inline void DBOfflineEvent::set_strparam1(const ::std::string& value) {
  set_has_strparam1();
  if (strparam1_ == &::google::protobuf::internal::kEmptyString) {
    strparam1_ = new ::std::string;
  }
  strparam1_->assign(value);
}
inline void DBOfflineEvent::set_strparam1(const char* value) {
  set_has_strparam1();
  if (strparam1_ == &::google::protobuf::internal::kEmptyString) {
    strparam1_ = new ::std::string;
  }
  strparam1_->assign(value);
}
inline void DBOfflineEvent::set_strparam1(const char* value, size_t size) {
  set_has_strparam1();
  if (strparam1_ == &::google::protobuf::internal::kEmptyString) {
    strparam1_ = new ::std::string;
  }
  strparam1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBOfflineEvent::mutable_strparam1() {
  set_has_strparam1();
  if (strparam1_ == &::google::protobuf::internal::kEmptyString) {
    strparam1_ = new ::std::string;
  }
  return strparam1_;
}
inline ::std::string* DBOfflineEvent::release_strparam1() {
  clear_has_strparam1();
  if (strparam1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strparam1_;
    strparam1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBOfflineEvent::set_allocated_strparam1(::std::string* strparam1) {
  if (strparam1_ != &::google::protobuf::internal::kEmptyString) {
    delete strparam1_;
  }
  if (strparam1) {
    set_has_strparam1();
    strparam1_ = strparam1;
  } else {
    clear_has_strparam1();
    strparam1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string strparam2 = 9;
inline bool DBOfflineEvent::has_strparam2() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DBOfflineEvent::set_has_strparam2() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DBOfflineEvent::clear_has_strparam2() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DBOfflineEvent::clear_strparam2() {
  if (strparam2_ != &::google::protobuf::internal::kEmptyString) {
    strparam2_->clear();
  }
  clear_has_strparam2();
}
inline const ::std::string& DBOfflineEvent::strparam2() const {
  return *strparam2_;
}
inline void DBOfflineEvent::set_strparam2(const ::std::string& value) {
  set_has_strparam2();
  if (strparam2_ == &::google::protobuf::internal::kEmptyString) {
    strparam2_ = new ::std::string;
  }
  strparam2_->assign(value);
}
inline void DBOfflineEvent::set_strparam2(const char* value) {
  set_has_strparam2();
  if (strparam2_ == &::google::protobuf::internal::kEmptyString) {
    strparam2_ = new ::std::string;
  }
  strparam2_->assign(value);
}
inline void DBOfflineEvent::set_strparam2(const char* value, size_t size) {
  set_has_strparam2();
  if (strparam2_ == &::google::protobuf::internal::kEmptyString) {
    strparam2_ = new ::std::string;
  }
  strparam2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DBOfflineEvent::mutable_strparam2() {
  set_has_strparam2();
  if (strparam2_ == &::google::protobuf::internal::kEmptyString) {
    strparam2_ = new ::std::string;
  }
  return strparam2_;
}
inline ::std::string* DBOfflineEvent::release_strparam2() {
  clear_has_strparam2();
  if (strparam2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strparam2_;
    strparam2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DBOfflineEvent::set_allocated_strparam2(::std::string* strparam2) {
  if (strparam2_ != &::google::protobuf::internal::kEmptyString) {
    delete strparam2_;
  }
  if (strparam2) {
    set_has_strparam2();
    strparam2_ = strparam2;
  } else {
    clear_has_strparam2();
    strparam2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 timetick = 10;
inline bool DBOfflineEvent::has_timetick() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DBOfflineEvent::set_has_timetick() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DBOfflineEvent::clear_has_timetick() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DBOfflineEvent::clear_timetick() {
  timetick_ = GOOGLE_ULONGLONG(0);
  clear_has_timetick();
}
inline ::google::protobuf::uint64 DBOfflineEvent::timetick() const {
  return timetick_;
}
inline void DBOfflineEvent::set_timetick(::google::protobuf::uint64 value) {
  set_has_timetick();
  timetick_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace message
}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_db_5fplayer_2eproto__INCLUDED
